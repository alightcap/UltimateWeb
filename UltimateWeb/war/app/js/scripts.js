'use strict';

angular.module('newBetaApp', [
  'ngRoute',
  'ngAnimate',
  'ngCookies'
])
  .config(['$routeProvider',
    function($routeProvider) {
      function checkAuth($location, Authorization, next) {
        next.set($location.path());
        return Authorization.ping($location.url().match(/^\/\d+/)[0].slice(1));
      }
      function logRoute($location){
        if (typeof _gaq !== 'undefined' && _gaq.push){
          var pageRoute = $location.url().replace(/\/\d+\//, '').match(/\w+/)[0];
          _gaq.push(['_trackPageview', pageRoute.slice(0,1).toUpperCase() + pageRoute.slice(1)]);
        }
      }

      $routeProvider
        .when('/', {templateUrl: 'views/splash.html', resolve: {ga: logRoute}})
        .when('/:teamId/login', {templateUrl: 'views/login.html', controller: 'LoginCtrl', resolve: {ga: logRoute}})
        .when('/:teamId/players', {templateUrl: 'views/players.html', controller: 'PlayersCtrl', resolve: {authorized: checkAuth, ga: logRoute}})
        .when('/:teamId/team', {templateUrl: 'views/team.html', controller: 'TeamCtrl', resolve: {authorized: checkAuth, ga: logRoute}})
        .when('/:teamId/download', {templateUrl: 'views/download.html', controller: 'DownloadCtrl', resolve: {authorized: checkAuth, ga: logRoute}})
        .when('/:teamId/line', {templateUrl: 'views/line.html', controller: 'LineCtrl', resolve: {authorized: checkAuth, ga: logRoute}})
        .when('/:teamId/games', {templateUrl: 'views/games.html', controller: 'GamesCtrl', resolve: {authorized: checkAuth, ga: logRoute}})
        .when('/:teamId/player/:playerNameUri', {templateUrl: 'views/player.html', controller: 'PlayerCtrl', resolve: { authorized: checkAuth, ga: logRoute}})
        .when('/:teamId/share/:stateType/:stateId', {templateUrl: 'views/state-loading.html', controller: 'ShareCtrl', resolve: { authorized: checkAuth, ga: logRoute}})
        .when('/404', {templateUrl: 'views/404.html', controller: '404Ctrl'})
        .otherwise({redirectTo: '/404'});
    }
  ]);
;'use strict';

angular.module('newBetaApp')
  .controller('404Ctrl', ['$scope',function ($scope) {
  }]);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').controller('BroadcastCtrl', function($scope) {
    return $scope.loading = false;
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  angular.module('newBetaApp').controller('DownloadCtrl', [
    '$scope', 'downloadUrl', function($scope, downloadUrl) {
      return $scope.url = downloadUrl;
    }
  ]);

}).call(this);
;/* global _ */

'use strict';

angular.module('newBetaApp')
  .controller('FilterCtrl', ['$scope', 'filter', 'allGames', function($scope, filter, allGames) {
    $scope.dDOpen = false;
    $scope.filter = filter;
    $scope.buttonMessage = 'All Games';
    allGames.then(function(games) {
      $scope.allGames = games;
      $scope.numberOfGames = Object.keys(games).length;
      $scope.mostRecentGame = _.max(games, function(item) {
        return item.msSinceEpoch;
      });
      $scope.tournaments = _.groupBy(games, 'tournamentName');
      $scope.mostRecentTournamentName = $scope.mostRecentGame.tournamentName;
      $scope.mostRecentTournament = $scope.mostRecentTournamentName ? $scope.tournaments[$scope.mostRecentGame.tournamentName] : null;
      if ($scope.tournaments && $scope.tournaments['undefined']) {
        $scope.tournaments['-'] = $scope.tournaments['undefined'];
        delete $scope.tournaments['undefined'];
      }
    });

    function orderLayout() {
      $scope.orderedTournaments = _.map($scope.tournaments,function(games) {
        return _.toArray(games).sort(function(a, b) {
          return b.msSinceEpoch - a.msSinceEpoch;
        });
      }).sort(function(a, b) {
        return b[0].msSinceEpoch - a[0].msSinceEpoch;
      });
    }
    $scope.collect = function() {
      orderLayout();
      $scope.dDOpen = true;
    };
    $scope.close = function() {$scope.dDOpen = false;};
    $scope.isIncluded = filter.contains;
    $scope.allIncluded = function(games){
      return _.reduce(games, function(memo, game){
        return memo && $scope.isIncluded(game);
      }, true);
    };
    $scope.toggleAll = function(games, choice){
      _.each(games, function(game){
        $scope.toggleSelect(game, choice);
      });
    };
    $scope.toggleSelect = function(game, choice){
      (!filter.contains(game) || choice) ? filter.include(game) : filter.exclude(game);
    };
    var $dedicatedScope = $scope.$new();
    $dedicatedScope.included = filter.included;
    $dedicatedScope.$watchCollection('included', function(){
      updateSelectorMessage()
    });
    $dedicatedScope.$watch('tournaments', function(){
      updateSelectorMessage()
    });
    function updateSelectorMessage(){
      // this is the logic for the filter button's message. It's a nest, I know, but it's O(n).
      // if tournaments have been established, run the following logic:
        // Say all games (n games) if all are selected.
        // else Say a tournament name (+n games other than that tournament)
        // else Say the most recent game selected, and (+n games other than selected)
      // if there are any games selected and no tournaments, it means this is the first load, ergo append the number of games to the message so it's All Games (n games), instead of just all games.
      // Otherwise they don't have any stats recorded, so tell them.
      //TODO: unit test this piece of shit...


      if ($scope.tournaments){
        var possibilities = {
          total: true,
          tournaments: _.clone($scope.tournaments),
          games: _.clone($scope.allGames, 'gameId')
        };
        delete possibilities.tournaments['-'];
        var current = _(filter.included).indexBy('gameId').valueOf();
        _.each($scope.allGames, function(game){
          if (!_(current).has(game.gameId)){
            delete possibilities.total;
            delete possibilities.tournaments[game.tournamentName];
            delete possibilities.games[game.gameId];
          }
        });
        if (possibilities.total){
          $scope.buttonMessage = 'All Games ' + '(' + filter.included.length + ' games)';
        } else if (_.keys(possibilities.tournaments).length){
          var tourney = _(possibilities.tournaments).sample();
          var extraGames = filter.included.length - tourney.length ? ' (+' + (filter.included.length - tourney.length) + ' games)' : '';
          $scope.buttonMessage = tourney[0].tournamentName + extraGames;
        } else if (filter.included.length){
          var extraGames = filter.included.length > 1 ? ' (+' + (filter.included.length - 1) + ' games)' : '';
          $scope.buttonMessage = _.min(filter.included, 'msSinceEpoch').opponentName + extraGames;
        } else {
          $scope.buttonMessage = 'Zero Games Selected!';
        }
      } else if (filter.included.length) {
        $scope.buttonMessage += ' (' + filter.included.length + ' games)';
      } else {
        $scope.buttonMessage = 'You don\'t have any stats!';
      }
    }
  }]);;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').controller('GamesCtrl', [
    '$scope', '$q', '$location', 'allGames', 'playerStats', 'gameStats', 'filter', 'relocate', function($scope, $q, $location, allGames, playerStats, gameStats, filter, relocate) {
      var openPoints, scope;
      scope = $scope;
      scope.relocate = relocate;
      scope.loading = true;
      $q.all([allGames, playerStats, gameStats, filter]).then(function(responses) {
        var id;
        allGames = responses[0];
        gameStats = responses[2];
        filter = responses[3];
        $location.replace();
        try {
          id = _.keys($location.search())[0];
          if (allGames[id]) {
            scope.select(allGames[id]);
          } else {
            scope.select(_.max(allGames, function(game) {
              return game.msSinceEpoch;
            }));
          }
        } catch (_error) {
          scope.select(_.max(allGames, function(game) {
            return game.msSinceEpoch;
          }));
        }
        scope.loading = false;
        return scope.sortedGames = _.toArray(allGames);
      });
      scope.isSelectedGame = function(game) {
        return game === scope.selectedGame;
      };
      scope.select = function(game) {
        scope.gameLoading = true;
        filter.onlyInclude([game]);
        $location.search(game.gameId);
        scope.selectedGame = game;
        scope.gameStats = gameStats.getFor(game);
        return scope.gameLoading = false;
      };
      openPoints = {};
      scope.togglePoints = function(points, only) {
        if (only) {
          openPoints = {};
        }
        return _(points).pluck('$$hashKey').each(function(id) {
          return openPoints[id] = !openPoints[id];
        });
      };
      return scope.isOpen = function(point) {
        return openPoints[point['$$hashKey']];
      };
    }
  ]);

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').controller('LineCtrl', [
    '$scope', '$q', 'team', 'lineStats', 'LineView', 'filter', 'viewer', 'savedState', function($scope, $q, team, lineStats, LineView, filter, viewer, savedState) {
      var scope, setFromSaved;
      scope = $scope;
      scope.dragging;
      scope.includedGames = filter.included;
      $scope.loading = true;
      scope.lineViews = [];
      $scope._bind = _.bind;
      scope.lineViews.push(new LineView);
      if (viewer.isLargeScreen()) {
        scope.lineViews.push(new LineView);
      }
      scope.selectedLineView = _.first(scope.lineViews);
      $q.all([lineStats, team]).then(function(response) {
        team = response[1];
        lineStats = response[0];
        savedState = savedState.getOnce();
        $scope.players = _.pluck(team.players, 'name');
        $scope.teamStats = lineStats.getForTeam();
        if (savedState.lines) {
          setFromSaved(savedState.lines);
        } else {
          _.each(scope.lineViews, function(lineView) {
            return lineView.addLine();
          });
        }
        return $scope.loading = false;
      });
      scope.$watchCollection('includedGames', function(update, old) {
        if (update && lineStats.getStats) {
          _(scope.lineViews).each(function(lineView) {
            return lineView.updateStats();
          });
          return $scope.teamStats = lineStats.getForTeam();
        }
      });
      scope.setDragging = function(player) {
        return scope.dragging = player;
      };
      scope.addPlayerToSelected = function(player) {
        return scope.selectedLineView.selectedLine.addPlayers(player);
      };
      scope.isSelectedLineView = function(lineView) {
        return scope.selectedLineView === lineView;
      };
      scope.selectLineView = function(lineView) {
        scope.selectedLineView = lineView;
        return lineView.selectedLine.updateStats();
      };
      scope._keys = _.keys;
      scope._contains = _.contains;
      scope.isNumber = function(item) {
        return typeof item === 'number';
      };
      scope.floor = Math.floor;
      scope.getSharedData = function() {
        var data;
        data = scope.$parent.getSharedData();
        data.lines = [];
        _.each(scope.lineViews, function(view, lvIndex) {
          return _.each(view.lines, function(line) {
            console.log(line.getPlayers());
            return data.lines.push({
              players: line.getPlayers(),
              index: lvIndex,
              isSelected: view.isSelectedLine(line)
            });
          });
        });
        return data;
      };
      return setFromSaved = function(lineObjects) {
        return _.each(lineObjects, function(lineObj) {
          var appropriateLineView, line;
          appropriateLineView = $scope.lineViews[lineObj.index % $scope.lineViews.length];
          line = appropriateLineView.addLine(true);
          line.addPlayers(lineObj.players);
          if (lineObj.isSelected) {
            return appropriateLineView.selectLine(line);
          }
        });
      };
    }
  ]);

}).call(this);
;'use strict';

angular.module('newBetaApp')
  .controller('LoginCtrl', ['$scope', '$routeParams', '$location', 'api', 'next', function($scope, $routeParams, $location, api, next) {
    $scope.attempt = function(password) {
      if (password){
        $scope.inAttempt = true;
        api.signon($routeParams.teamId, password,
          function() {
            var goTo = next.get();
            goTo ? $location.path(goTo) : $location.path($routeParams.teamId + '/players');
            $scope.$apply();
          }, function() {
            $scope.inAttempt = false;
            $scope.failedAttempt = true;
            $scope.$digest();
          });
      }
    };
  }]);;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').controller('MainCtrl', function($rootScope, filter) {
    return $rootScope.getSharedData = function() {
      var data;
      data = {};
      data.gameIds = _.pluck(filter.included, 'gameId');
      return data;
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').controller('PlayerCtrl', [
    '$scope', '$routeParams', '$q', 'allGames', 'playerExtensionStats', 'filter', 'team', function($scope, $routeParams, $q, allGames, playerExtensionStats, filter, team) {
      var init, players, scope;
      scope = $scope;
      scope.loading = true;
      scope.console = console;
      players = null;
      scope.playerName = decodeURI($routeParams.playerNameUri);
      $q.all([allGames, playerExtensionStats]).then(function(responses) {
        allGames = responses[0];
        playerExtensionStats = responses[1];
        init();
        return scope.loading = false;
      });
      return init = function() {
        filter.includeAll();
        scope.included = filter.included;
        playerExtensionStats.setPlayer(scope.playerName);
        return scope.$watchCollection('included', function() {
          playerExtensionStats.setGames(scope.included);
          return scope.targetStats = playerExtensionStats.getTargetMap();
        });
      };
    }
  ]);

}).call(this);
;/* global _ */

'use strict';

angular.module('newBetaApp')
  .controller('PlayersCtrl', ['$scope', '$q', 'playerStats', 'allGames', 'filter', 'relocate', function ($scope, $q, playerStats, allGames, filter, relocate) {
    $scope.relocate = relocate;
    $scope.loading = true;
    $scope.sortBy = 'name';
    $q.all([playerStats, allGames]).then(function(responses){
      filter.includeAll();
      playerStats = responses[0];
      allGames = responses[1];
      playerStats.setGames(allGames);
      $scope.playerStats = playerStats.getAll();
      $scope.statTypes = playerStats.statTypes;
      $scope.numberOfGames = Object.keys(allGames).length;
      $scope.included = filter.included;
      $scope.$watchCollection('included', function(){
        playerStats.setGames(filter.included);
        $scope.playerStats = playerStats.getAll();
        render(); // fucking digest loop.
      });
      $scope.loading = false;
      render();
    });
    $scope.console = console;
    $scope.leaderMap = {
      goals: {
        category: 'Offense',
        stats: ['goals', 'assists','touches']
      },
      ds : {
        category: 'Defense',
        stats: ['ds','dPoints', 'pulls']
      },
      plusMinus: {
        category: 'Plus / Minus',
        stats: ['plusMinus', 'oPlusMinus','dPlusMinus']
      },
      pointsPlayed: {
        category: 'Playing Time',
        stats: ['oPoints','dPoints','minutesPlayed']
      }
    };
    function render() {
      $scope.leaders = playerStats.getLeaders(['goals','ds','pointsPlayed', 'plusMinus']);
    }
  }]);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').controller('ShareCtrl', function($scope, $routeParams, $location, api, allGames, filter, savedState) {
    return api.retrieveState($routeParams.teamId, $routeParams.stateId, $routeParams.stateType, function(response) {
      return allGames.then(function(games) {
        var data;
        data = JSON.parse(response.json);
        savedState.set(data);
        filter.onlyInclude(_.reduce(data.gameIds, function(memo, gameId) {
          memo.push(games[gameId]);
          return memo;
        }, []));
        $location.replace();
        return $location.url("" + $routeParams.teamId + "/" + response.type);
      });
    });
  });

}).call(this);
;/* global _ */

'use strict';

angular.module('newBetaApp')
  .controller('StattablesCtrl', ['$scope', '$location','$routeParams', 'playerStats', 'filter', 'relocate', function($scope, $location,$routeParams, playerStats, filter, relocate) {
    $scope.relocate = relocate;
    $scope.changeFocus = function(type) {
      $scope.focus = type;
    };
    playerStats.then(function(statsApi) {
      playerStats = statsApi;
      init();
    });
    $scope.categories = [
      {
        name: 'Summary',
        statTypes: ['plusMinus', 'oEfficiency', 'dEfficiency', 'passingPercentage', 'pointsPlayed']
      }, {
        name: 'Passing',
        statTypes: ['assists', 'completions', 'throwaways','stalls', 'passingPercentage']
      }, {
        name: 'Receiving',
        statTypes: ['goals','catches','touches','drops','catchingPercentage']
      }, {
        name: 'Playing Time',
        statTypes: ['gamesPlayed','pointsPlayed','minutesPlayed', 'oPoints', 'dPoints']
      }, {
        name: 'Defense',
        statTypes: ['ds','pulls','callahans','averagePullHangtime','oBPulls',]
      }, {
        name: 'Per Point',
        statTypes: ['ppGoals' ,'ppAssists', 'ppDs' , 'ppThrowaways' , 'ppDrops']
      }
    ];
    $scope.focus = $scope.categories[0];
    $scope.games = filter.included; // updated by the filter controller.
    $scope.sorter = 'name';
    $scope.inclineSort = false;
    function init(){
      $scope.stats = playerStats.getAll();
      $scope.players = _.keys($scope.stats);
      $scope.statTypes = _.keys($scope.stats[$scope.players[0]].stats);
      startWatching();
    }
    function startWatching(){
      $scope.$watchCollection('games', function(nv, ov) {
        playerStats.setGames(filter.included);
        $scope.stats = playerStats.getAll();
        $scope.statsArray = _.toArray($scope.stats);
        $scope.players = _.keys($scope.stats);
        $scope.statTypes = _.keys($scope.stats[$scope.players[0]].stats);
        $scope.totals = playerStats.getTotals();
        $scope.averages = playerStats.getAverages();
      });
    }
    $scope.sort = function(property){
      $scope.inclineSort = $scope.sorter === property && !$scope.inclineSort
      $scope.sorter = property
    };
  }]);
;'use strict';

angular.module('newBetaApp')
  .controller('TeamCtrl', ['$scope', 'teamStats', '$location','filter',function($scope, teamStats, $location, filter) {
    $scope.loading = true;
    teamStats.then(function(api) {
      filter.includeAll()
      $scope.teamStats = api.getFromIncluded();
      $scope.loading = false;
    });
  }]);;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').directive('actionField', function() {
    return {
      templateUrl: 'includes/partials/field.html',
      restrict: 'E',
      link: function(scope, element, attrs) {}
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').directive('bubblePie', function() {
    return {
      restrict: 'E',
      template: '<chart-key color-scheme="colorMap"></chart-key>',
      scope: {
        data: '='
      },
      link: function(scope, element, attrs) {
        var color, format, render;
        format = d3.format(",d");
        color = d3.scale.category20c();
        $(window).resize(function() {
          if (scope.data) {
            return render(scope.data);
          }
        });
        scope.$watch('data', function(newData) {
          if (newData) {
            return render(newData);
          }
        });
        return render = function(data) {
          var bubble, bubbles, d3Svg, persister, pie, size;
          scope.colorMap = {};
          element.find('svg').remove();
          size = $(element).parent().width();
          d3Svg = d3.select(element[0]).append('svg').attr('width', size).attr('height', size).attr('class', 'bubble-pie');
          pie = d3.layout.pie().value(function(d) {
            return d.value;
          });
          bubble = d3.layout.pack().sort(null).size([size, size]).padding(5);
          bubbles = d3Svg.selectAll('.bubble').data(bubble.nodes(data).filter(function(d) {
            return !d.children;
          })).enter().append('g').attr('class', 'bubble').attr('transform', function(d) {
            return "translate(" + d.x + "," + d.y + ")";
          });
          bubbles.append('text').attr('dy', '.3em').style('text-anchor', 'middle').text(function(d) {
            return d.playerName.substring(0, d.r / 3);
          });
          persister = {};
          return _.each(bubbles[0], function(bubble) {
            var arc, arcs;
            data = bubble.__data__;
            persister["arc" + data.id] = d3.svg.arc().outerRadius(data.r);
            persister["arcs" + data.id] = d3Svg.selectAll("g.slice" + data.id).data(pie(data.stats)).enter().insert("svg:g", ":first-child").attr("class", "slice" + data.id).attr("transform", "translate( " + data.x + ", " + data.y + ")");
            arc = persister["arc" + data.id];
            arcs = persister["arcs" + data.id];
            arcs.append("svg:path").attr("fill", function(d, i) {
              var tempColor;
              tempColor = color(i);
              if (_.isNaN(d.endAngle)) {
                d.endAngle = 0;
              }
              if (_.isNaN(d.startAngle)) {
                d.startAngle = 0;
              }
              if (d.data.label !== 'Catch') {
                scope.colorMap[d.data.label] = tempColor;
              }
              return tempColor;
            }).attr("d", arc);
            return arcs.append("title").text(function(d, i) {
              return "" + d.value + " " + data.stats[i].label + "s";
            });
          });
        };
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').directive('chartKey', function() {
    return {
      templateUrl: 'includes/partials/chart-key.html',
      restrict: 'E',
      scope: {
        colorScheme: '='
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').directive('draggable', [
    '$parse', function($parse) {
      return {
        restrict: 'A',
        link: function(scope, element, attrs) {
          var item, onDrag;
          item = $parse(attrs.item)(scope);
          onDrag = $parse(attrs.onDrag)(scope);
          return element.on('dragstart', function() {
            return onDrag(item);
          });
        }
      };
    }
  ]);

}).call(this);
;
'use strict';

angular.module('newBetaApp')
  .directive('dropdownButton', ['$document',function ($document) {
    return {
      restrict: 'A',
      link: function postLink(scope, iElement) {
        var theElement;
        var display;
        var isOpen = false;
        var targeted = false;
        scope.dDRegister = function(element){
          theElement = element;
          hideElement();
          delete scope.dDRegister;
          theElement.on('click', function(e){
            targeted = true;
          });
        };
        iElement.on('click', function(){
          isOpen = !isOpen;
          if (isOpen){
            theElement.css('display', display);
          } else {
            hideElement();
          }
        });
        $document.on('click', function(e){
          if (e.target !== iElement[0] && !_.contains(iElement.children(), e.target)) {
            isOpen = false;
            theElement.css('display', 'none');
          }
        });
        function hideElement(){
          isOpen = false;
          display = theElement.css('display');
          theElement.css('display', 'none');
        }
      }
    };
  }]);
;'use strict';

angular.module('newBetaApp')
  .directive('dropdownTarget', function () {
    return {
      restrict: 'A',
      link: function postLink(scope, element) {
        scope.dDRegister(element);
      }
    };
  });
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').directive('droppable', [
    '$parse', function($parse) {
      return {
        restrict: 'A',
        scope: true,
        link: function(scope, element, attrs) {
          var onDrop, onEnter, onLeave;
          onEnter = $parse(attrs.onEnter)(scope);
          onLeave = $parse(attrs.onLeave)(scope);
          onDrop = $parse(attrs.onDrop)(scope);
          element.on('dragenter', function(event) {
            return typeof onEnter === "function" ? onEnter(scope.dragging) : void 0;
          });
          element.on('dragleave', function(event) {
            return typeof onLeave === "function" ? onLeave(scope.dragging) : void 0;
          });
          element.on('drop', function(event) {
            return scope.$apply(function() {
              return typeof onDrop === "function" ? onDrop(scope.dragging) : void 0;
            });
          });
          return element.on('dragover', function(event) {
            if (typeof onOver === "function") {
              onOver(scope.dragging);
            }
            return event.preventDefault();
          });
        }
      };
    }
  ]);

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').directive('explanation', function(calculationExplanations, $sce) {
    return {
      templateUrl: 'includes/partials/explanation.html',
      restrict: 'E',
      replace: true,
      scope: {
        key: '=',
        trigger: '='
      },
      link: function(scope, element, attrs) {
        var description, _ref;
        element.parent().on('mouseenter', function(event) {
          return scope.$apply(function() {
            return scope.showPrompt = !scope.shouldShowToolTip;
          });
        });
        element.parent().on('mouseleave', function() {
          return scope.$apply(function() {
            return scope.showPrompt = false;
          });
        });
        description = (_ref = calculationExplanations[scope.key]) != null ? _ref.explanations[0].description : void 0;
        scope.hasDescription = !!description;
        scope.explanation = $sce.trustAsHtml(description || 'Ask us personally about this one if you\'d like.');
        scope.showTooltip = function() {
          return setTimeout(function() {
            return scope.$apply(function() {
              var $explanationTooltip, documentWidth, elementRightOffset;
              elementRightOffset = $(element).offset().left + 200;
              documentWidth = $(document).width();
              $explanationTooltip = $(element).find('.explanation-tooltip');
              if (documentWidth < elementRightOffset) {
                $explanationTooltip.css('left', -1 * (elementRightOffset - documentWidth));
              }
              scope.shouldShowToolTip = true;
              return scope.showPrompt = false;
            });
          });
        };
        scope.hideTooltip = function() {
          return scope.shouldShowToolTip = false;
        };
        return $(window).on('click', function(event) {
          if (!(scope.shouldShowToolTip === false || event.currentTarget === $(element).find('span.explanation-description')[0])) {
            return scope.$apply(function() {
              return scope.hideTooltip();
            });
          }
        });
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').directive('feedback', [
    function() {
      return {
        templateUrl: 'includes/partials/feedback.html',
        restrict: 'E',
        link: function(scope, element, attrs) {
          scope.gotMobileWarning = _(document.cookie).contains('mobile');
          scope.firstTime = !_(document.cookie).contains('visited');
          scope.submitted = false;
          scope.closeFirstTimeModal = function() {
            scope.firstTime = false;
            return document.cookie = 'visited=true;max-age=100000000000';
          };
          return scope.closeMobileWarning = function() {
            scope.gotMobileWarning = true;
            return document.cookie = 'mobile-visited=true;max-age=100000000000';
          };
        }
      };
    }
  ]);

}).call(this);
;/*global d3, angular */
angular.module('newBetaApp')
  .directive('flowChart', function($rootScope) {
    return {
      restrict: 'AE',
      template: '<svg></svg>',
      scope: {
        dataset: '='
      },
      compile: function() {
        return {
          pre: function(scope, element) {
            scope.svg = d3.select(element.children()[0]);
          },
          post: function (scope, element) {
            $(window).resize(function(){
              render();
            });

            scope.$watch('dataset', function(newVal, oldVal) {
              render();
            });
            function render(){
              if (scope.dataset){
                element.contents().empty();
                var margin = {
                  top: 1,
                  right: 1,
                  bottom: 6,
                  left: 1
                };
                var width = $(element.parent()).width() * .95;
                var height = width;

                if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement){
                  width = $(window).width() - 80;
                  height = $(window).height() - 80;
                }

                var formatNumber = d3.format(',.0f');
                var format = function(d) {
                  return formatNumber(d) + ' Times';
                };
                var color = d3.scale.category20();

                scope.svg
                  .attr('width', width + margin.left + margin.right)
                  .attr('height', height + margin.top + margin.bottom)
                  .append('g')
                  .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

                var sankey = d3.sankey()
                  .nodeWidth(15)
                  .nodePadding(10)
                  .size([width, height]);

                var path = sankey.link();

                sankey
                  .nodes(scope.dataset.nodes)
                  .links(scope.dataset.links)
                  .layout(32);

                var link = scope.svg.append('g').selectAll('.link')
                  .data(scope.dataset.links)
                  .enter().append('path')
                  .attr('class', 'link')
                  .attr('d', path)
                  .style('stroke-width', function(d) {
                    return Math.max(1, d.dy);
                  })
                  .sort(function(a, b) {
                    return b.dy - a.dy;
                  });

                link.append('title')
                  .text(function(d) {
                    return $rootScope.getName(d.source.name.slice(0, d.source.name.length - 1), 'shortened') + ' → ' + $rootScope.getName(d.target.name.slice(0, d.target.name.length - 1), 'shortened') + '\n' + format(d.value);
                  });
                var node = scope.svg.append('g').selectAll('.node')
                  .data(scope.dataset.nodes)
                  .enter().append('g')
                  .attr('class', 'node')
                  .attr('transform', function(d) {
                    return 'translate(' + d.x + ',' + d.y + ')';
                  })
                  .call(d3.behavior.drag()
                    .origin(function(d) {
                      return d;
                    })
                    .on('dragstart', function() {
                      this.parentNode.appendChild(this);
                    })
                    .on('drag', dragmove));

                node.append('rect')
                  .attr('height', function(d) {
                    return d.dy;
                  })
                  .attr('width', sankey.nodeWidth())
                  .style('fill', function(d) {
                    return d.color = color(d.name.replace(/ .*/, ""));
                  })
                  .style('stroke', function(d) {
                    return d3.rgb(d.color).darker(2);
                  })
                  .append('title')
                  .text(function(d) {
                    return $rootScope.getName(d.name, 'shortened') + '\n' + format(d.value);
                  });

                node.append('text')
                  .attr('x', -6)
                  .attr('y', function(d) {
                    return d.dy / 2;
                  })
                  .attr('dy', '.35em')
                  .attr('text-anchor', 'end')
                  .attr('transform', null)
                  .text(function(d) {
                    return $rootScope.getName(d.name.substring(0, d.name.length - 1), 'shortened');
                  })
                  .filter(function(d) {
                    return d.x < width / 2;
                  })
                  .attr('x', 6 + sankey.nodeWidth())
                  .attr('text-anchor', 'start');

                var dragmove = function(d) {
                  d3.select(this).attr('transform', 'translate(' + d.x + ',' + (d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))) + ')');
                  sankey.relayout();
                  link.attr('d', path);
                }
              }
            }
          }
        };
      }
    };
  });;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').directive('footer', function() {
    return {
      templateUrl: './includes/partials/footer.html',
      restrict: 'EA',
      link: function(scope, element, attrs) {
        $('.main-view').css('min-height', window.innerHeight - $('.extra').outerHeight() - $('.footer').outerHeight());
        return $(window).resize(function() {
          return $('.main-view').css('min-height', window.innerHeight - $('.extra').outerHeight() - $('.footer').outerHeight());
        });
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').directive('fullScreen', function() {
    return {
      template: '<i class="icon-fullscreen">',
      restrict: 'E',
      scope: {
        key: '='
      },
      link: function(scope, element, attrs) {
        return element.on('click', function() {
          var requestFullscreen, targetElement;
          requestFullscreen = element[0].requestFullscreen || element[0].webkitRequestFullScreen || element[0].mozRequestFullScreen || element[0].msRequestFullScreen;
          targetElement = $("[fs-target=" + scope.key + "]")[0];
          return requestFullscreen.call(targetElement);
        });
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').directive('heatMap', function() {
    return {
      templateUrl: 'includes/partials/field.html',
      restrict: 'E',
      link: function(scope, element, attrs) {}
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').directive('lineChart', function() {
    return {
      restrict: 'E',
      template: '<chart-key color-scheme="colorMap"></chart-key>',
      scope: {
        lines: '='
      },
      link: function(scope, element, attrs) {
        var color, format, render;
        format = d3.format(",d");
        color = d3.scale.category20c();
        $(window).resize(function() {
          if (scope.lines) {
            return render(scope.lines);
          }
        });
        scope.$watch('lines', function(newData) {
          if (newData) {
            return render(newData);
          }
        });
        return render = function(data) {
          var d3Svg, fontSize, graphLines, height, line, lines, margin, maxXValue, size, width, x, xAxis, y, yAxis;
          scope.colorMap = {};
          element.find('svg').remove();
          size = $(element).parent().width();
          fontSize = 10;
          margin = {
            top: 0,
            right: 80,
            bottom: 20,
            left: 40
          };
          width = size - margin.left - margin.right - fontSize;
          height = size / 2 - margin.top - margin.bottom - fontSize * 2;
          d3Svg = d3.select(element[0]).append('svg').attr("width", width + margin.left + margin.right + fontSize).attr("height", height + margin.top + margin.bottom + fontSize * 2).attr('class', 'line-chart').append("g").attr("transform", "translate(" + margin.left + "," + fontSize + ")");
          x = d3.scale.linear().range([0, width]);
          y = d3.scale.linear().range([height, 0]);
          xAxis = d3.svg.axis().scale(x).orient('bottom');
          yAxis = d3.svg.axis().scale(y).orient('left');
          line = d3.svg.line().interpolate("basis").x(function(d) {
            return x(d.x);
          }).y(function(d) {
            return y(d.y);
          });
          color.domain(d3.keys(data));
          lines = color.domain().map(function(name) {
            return {
              name: name,
              values: data[name]
            };
          });
          maxXValue = 0;
          _.each(lines, function(line) {
            return _.each(line.values, function(value) {
              return maxXValue = _.max([maxXValue, value.x * 1]);
            });
          });
          x.domain([0, maxXValue]);
          y.domain([0, 100]);
          d3Svg.append("g").attr("class", "x axis").attr("transform", "translate( 0, " + height + " )").call(xAxis).append("text").attr("dy", ".71em").attr("transform", "translate( 0, " + margin.bottom + " )").text("Wind Speed (mph)");
          d3Svg.append("g").attr("class", "y axis").call(yAxis).append("text").attr("transform", "rotate(-90)").attr("y", -margin.left).attr("x", -1 * height / 2).attr("dy", ".71em").style("text-anchor", "end").text("Scored (percent)");
          graphLines = d3Svg.selectAll(".line").data(lines).enter().append("g").attr("class", "line");
          graphLines.append("path").attr("class", "line").attr("d", function(d) {
            return line(d.values);
          }).style("stroke", function(d) {
            return color(d.name);
          });
          return graphLines.append("text").datum(function(d) {
            return {
              name: d.name,
              value: d.values[d.values.length - 1]
            };
          }).attr("transform", function(d) {
            return "translate(" + (x(d.value.x)) + ", " + (y(d.value.y)) + " )";
          }).attr("x", 3).attr("dy", ".35em").text(function(d) {
            return d.name;
          });
        };
      }
    };
  });

}).call(this);
;/* global _ */

'use strict';

angular.module('newBetaApp')
  .directive('loading', function () {
    return {
      restrict: 'A',
      scope: {
        loading: '=',
        loadingType: '='
      },
      link: function preLink(scope, element){
        var message = '';
        if (!scope.loadingType || scope.loadingType.indexOf('icon') === -1){
          var i = -1;
          var myInt = setInterval(function(){
            if (++i === 4) {
              clearInterval(myInt);
            }
            element.children()[0].children[0].innerHTML = messages[i];
          },3000);
          var messages = [
            'Calculating Team Statistics...',
            'Calculating Game Statistics...',
            'Calculating Player Statistics...',
            'Calculating Other Data...',
            'Whoa... a long time has passed. Try refreshing the page.'
          ];
          message = messages[0];
        }
        element.prepend('<span class="9827345987"><b id="87654">'+message+'</b><br><img width="30" src="images/ajax-loader.gif"></span>');
        scope.$watch('loading', function(newVal){
          _.each(element.children(), function(node){
            node.hidden = (node.classList.contains('9827345987') && !newVal) || (!node.classList.contains('9827345987') && newVal);
          });
        });
      }
    };
  });
;'use strict';

angular.module('newBetaApp')
  .directive('navBar', ['viewer', '$routeParams', '$location', '$rootScope', function (viewer, $routeParams, $location, $rootScope) {
    return {
      templateUrl: 'includes/partials/nav-bar.html',
      restrict: 'EA',
      scope: {
        page: '=',
      },
      link: function postLink(scope) {
        scope.getName = $rootScope.getName
        scope.playerName = decodeURI($routeParams.playerNameUri);
        $rootScope.isMobile = viewer.isMobile();
        scope.isMobileSized = viewer.isMobileSized;
        scope.isActive = function(option){
          return option === scope.page ? 'active' : '';
        };
        scope.navTo = function(page){
          var path = '/' + $routeParams.teamId + '/' + page;
          if (page !== scope.page){ $location.path(path); }
        };
        scope.toggleNav = function(){
          scope.navOpen = !scope.navOpen;
        };
        scope.teamId = $routeParams.teamId
      }
    };
  }]);
;'use strict';

angular.module('newBetaApp')
  .directive('onEnter', ['$parse', '$document', function ($parse, $document) {
    return {
      restrict: 'A',
      link: function postLink(scope, element, attrs) {
        var toDo = $parse(attrs.onEnter);
        $document.on('keyup', function(e){
          if (e.keyCode === 13){
            toDo(scope);
          }
        });
      }
    };
  }]);
;/* global d3, _ */

'use strict';

angular.module('newBetaApp')
  .directive('pieChart', ['$parse',function ($parse) {
    return {
      template: '<svg></svg>',
      restrict: 'AE',
      scope: {
        dataset: '='
      },
      compile: function () {
        return {
            pre: function(scope, element, attrs){
              scope.svg = d3.select(element.children()[0]);
            },
            post: function(scope, element, attrs){
              scope.$watch('dataset', function(newVal){
                if (newVal && _.keys(newVal).length) initialized ? change(newVal) : init(newVal);
              });
              var g;
              var initialized = false;
              var width = $parse(attrs.width)(scope);
              var height = $parse(attrs.height)(scope);
              var radius = Math.min(width, height) / 2;

              var enterClockwise = {startAngle: 0, endAngle: 0};
              var enterAntiClockwise = {startAngle: Math.PI * 2, endAngle: Math.PI * 2 };

              var color = d3.scale.category20();
              var pie = d3.layout.pie()
                .sort(null)
                .value(function(d){ return d.iterations });

              var arc = d3.svg.arc().innerRadius(0).outerRadius(radius - 10);

              scope.svg
                  .attr('width', width)
                  .attr('height', height)
                .append('g')
                  .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

              function formatData(data){
                return _.reduce(data,function(memo, item, key){
                  memo.push({range: key, iterations: item});
                  return memo;
                },[]);
              }
              function change(newData){
                scope.svg.selectAll('g').remove()

                init(newData);
              }
              function init(data){
                initialized = true;
                g = scope.svg.selectAll('.arc')
                  .data(pie(formatData(data)))
                  .enter().append('g')
                  .attr('class', 'arc');

                g.append('path')
                  .attr('d', arc)
                  .style('fill', function(d, i) { return color(i); })
                  .each(function(d) { this.oldD = d; });

                g.append('text')
                  .attr('transform', function(d) {return 'translate(' + arc.centroid(d) + ')'; })
                  .attr('dy', '.35em')
                  .style('text-anchor', 'middle')
                  .style('fill','white')
                  .text(function(d) { return d.data.range; });

                g.attr('transform', 'translate('+ width / 2 +','+ width / 2 +')');

              }
            }
        };
      }
    };
  }]);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').directive('playerStatTable', [
    '$routeParams', 'playerStats', 'filter', function($routeParams, playerStats, filter) {
      return {
        templateUrl: 'includes/partials/playerStatTable.html',
        restrict: 'E',
        scope: {
          playerName: '='
        },
        link: function(scope, element, attrs) {
          var api, init;
          api = null;
          playerStats.then(function(response) {
            api = response;
            return init();
          });
          scope.included = filter.included;
          scope.$watchCollection('included', function() {
            if (api != null) {
              api.setGames(filter.included);
            }
            scope.playerStats = api != null ? api.getAll()[scope.playerName].stats : void 0;
            return scope.teamAverage = api != null ? api.getAverages() : void 0;
          });
          return init = function() {
            api.setGames(scope.included);
            scope.playerStats = api.getAll()[scope.playerName].stats;
            scope.teamAverage = api.getAverages();
            return scope.statTypes = _(scope.playerStats).omit(['timePlayed', 'hungPulls', 'pullHangtime']).keys(scope.playerStats).valueOf().sort();
          };
        }
      };
    }
  ]);

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').directive('rotating', function() {
    return {
      restrict: 'A',
      scope: {
        rotating: '='
      },
      compile: function() {
        return {
          pre: function(scope, element, attrs) {
            element.addClass('rotating');
            return scope.$watch('rotating', function(newVal, oldVal) {
              element.css('-webkit-transform', 'rotate(' + newVal + 'deg)');
              element.css('-moz-transform', 'rotate(' + newVal + 'deg)');
              return element.css('transform', 'rotate(' + newVal + 'deg)');
            });
          }
        };
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').directive('share', function($routeParams, $location, api, filter, allGames, teamName) {
    return {
      templateUrl: 'includes/partials/share.html',
      restrict: 'E',
      link: function(scope, element, attrs) {
        scope.escapeUrl = window.escape;
        teamName.then(function(response) {
          return scope.teamName = response;
        });
        scope.stopSharing = function() {
          return scope.sharingModalIsOpen = false;
        };
        scope.startSharing = function() {
          var stateType;
          scope.sharingModalIsOpen = true;
          stateType = $location.path().match(/\/[^\/]+\/\w+/)[0].replace(/\/[^\/]+\//, '');
          api.saveState($routeParams.teamId, stateType, JSON.stringify(scope.getSharedData() || {}), function(response) {
            return scope.$apply(function() {
              return scope.shareUrl = "" + window.location.host + "/#/" + $routeParams.teamId + "/share/" + response.type + "/" + response.stateId;
            });
          });
          return FB.init({
            appId: 1442600126018189,
            version: 'v2.0',
            status: true,
            xfbml: true
          });
        };
        return scope.fbShare = function() {
          return FB.ui({
            method: 'share',
            href: scope.shareUrl
          });
        };
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').directive('stackedLine', function() {
    return {
      template: '<div></div>',
      restrict: 'E',
      scope: {
        data: '='
      },
      link: function(scope, element, attrs) {
        var color, render;
        color = d3.scale.category20c();
        $(window).resize(function() {
          if (scope.lines) {
            return render(scope.lines);
          }
        });
        scope.$watch('data', function(newData) {
          if (newData) {
            return render(newData);
          }
        });
        return render = function(data) {
          var d3Svg, height, margin, size, width, x, xAxis, y, yAxis;
          element.find('svg').remove();
          size = $(element).parent().width();
          margin = {
            top: 20,
            right: 20,
            bottom: 30,
            left: 50
          };
          width = size - margin.left - margin.right;
          height = size / 2 - margin.top - margin.bottom;
          d3Svg = d3.select(element[0]).append('svg').attr("width", width + margin.left + margin.right + fontSize).attr("height", height + margin.top + margin.bottom + fontSize * 2).attr('class', 'stacked-line-chart').append("g").attr("transform", "translate(" + margin.left + "," + fontSize + ")");
          x = d3.scale.linear().range([0, width]);
          y = d3.scale.linear().range([height, 0]);
          xAxis = d3.svg.axis().scale(x).orient('bottom');
          return yAxis = d3.svg.axis().scale(y).orient('left');
        };
      }
    };
  });

}).call(this);
;/* global _ */

'use strict';

angular.module('newBetaApp')
  .directive('statFilter', function () {
    return {
      templateUrl: 'includes/partials/filter.html',
      restrict: 'EA',
      controller: 'FilterCtrl'
    };
  });
;'use strict';

angular.module('newBetaApp')
  .directive('statTables', function () {
    return {
      templateUrl: 'includes/partials/statTables.html',
      restrict: 'E',
      controller: 'StattablesCtrl'
    };
  });
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').directive('targetMap', [
    '$parse', '$rootScope', function($parse, $rootScope) {
      return {
        templateUrl: 'includes/partials/targetMap.html',
        restrict: 'E',
        scope: {
          data: '='
        },
        link: function(scope, element, attrs) {
          var diameter, getText, height, render;
          scope.keyEvents = ['Drop', 'Catch', 'Throwaway', 'Goal'];
          scope.getColor = function(action) {
            var color;
            return color = (function() {
              switch (false) {
                case action !== 'Drop':
                  return '#c5007c';
                case action !== 'Catch':
                  return '#949A27';
                case action !== 'Throwaway':
                  return '#ff9400';
                case action !== 'Goal':
                  return '#298020';
                default:
                  return '#c75aba';
              }
            })();
          };
          getText = function(data) {
            var at, dr, dv, plural, text;
            at = data.actionType;
            dv = $rootScope.getName(data.value, 'shortened');
            dr = $rootScope.getName(data.receiver, 'shortened');
            plural = dv > 1;
            return text = (function() {
              switch (false) {
                case at !== 'Throwaway':
                  return dv + (plural ? ' throwaways' : ' throwaway');
                case at !== 'Catch':
                  return dv + (plural ? ' passes to ' : ' pass to ') + dr;
                case at !== 'Goal':
                  return dv + (plural ? ' Goals to ' : ' Goal to ') + dr;
                case at !== 'Drop':
                  return dv + (plural ? ' dropped passes to ' : ' dropped pass to ') + dr;
                default:
                  return at + ', ' + dr;
              }
            })();
          };
          height = parseInt($(element.parent()).css('width')) + 150;
          diameter = height - 150;
          $(element.parent()).css('height', height);
          scope.$watch('data', function() {
            return render();
          });
          window.onresize = function() {
            return render();
          };
          return render = function() {
            var bubble, color, format, node, svg, tooltip;
            if (scope.data) {
              d3.select('#target-map').select('svg').remove();
              format = d3.format(',d');
              color = d3.scale.category20c();
              tooltip = d3.select('#target-map').append('div').attr('class', 'target-mouseover-tooltip').text('a simple tooltip');
              bubble = d3.layout.pack().sort(null).size([diameter, height + 100]).padding(1.5);
              svg = d3.select('#target-map').append('svg').attr('width', diameter).attr('height', height + 100).attr('class', 'bubble');
              node = svg.selectAll('.node').data(bubble.nodes(scope.data).filter(function(d) {
                return !d.children;
              })).enter().append('g').attr('class', 'target-node').attr('transform', function(d) {
                return 'translate(' + d.x + ',' + d.y + ')';
              }).on('mouseover', function(d) {
                return tooltip.style('visibility', 'visible').text(getText(d));
              }).on('mousemove', function() {
                return tooltip.style('top', d3.event.y - 10 + 'px').style('left', d3.event.x + 10 + 'px');
              }).on('mouseout', function() {
                return tooltip.style('visibility', 'hidden');
              });
              node.append('circle').attr("r", function(d) {
                return d.r;
              }).style("fill", function(d) {
                return scope.getColor(d.actionType, true);
              });
              node.append('text').attr('dy', '.5em').style('text-anchor', 'middle').text(function(d) {
                if (_.contains(d.receiver.toLowerCase(), 'anonymous')) {
                  return 'The other team';
                }
                return $rootScope.getName(d.receiver, 'shortened').substring(0, d.r / 3);
              });
              return d3.select(self.frameElement).style('height', diameter + 'px');
            }
          };
        }
      };
    }
  ]);

}).call(this);
;'use strict';

angular.module('newBetaApp')
  .directive('titleBar', ['$routeParams','teamName', function ($routeParams, teamName) {
    return {
      templateUrl: 'includes/partials/title-bar.html',
      restrict: 'EA',
      link: function postLink(scope, element) {
        var positionLogo = _.debounce(function(){
          var $uaLogo = $(element).find('.ua-logo');
          var $teamName = $(element).find('.navbar-brand');
          if ($($teamName.offsetParent()).width() - $teamName.offset().left - $teamName.outerWidth() - 22 < $uaLogo.outerWidth() ) { // I'm sorry father for I ahve sinned.
            $uaLogo.addClass('small-screen')
          } else {
            $uaLogo.removeClass('small-screen')
          }
        }, 75);
        if ( !_($routeParams).isEmpty() ){
          teamName.then(function(name){
            scope.teamName = name;
            window.document.title = name || 'ultiAnalytics';
            $(window).on('resize',function(){
              positionLogo();
            });
            positionLogo()
          });
        }
      }
    };
  }]);
;'use strict';

angular.module('newBetaApp')
  .filter('camelCase', function () {
    return function (name) {
      switch (name){
      case '':
        return '';
      default:
        var words = name.split(/(?=[A-Z])/g);
        words[0] = words[0][0].toUpperCase() + words[0].slice(1);
        return words.join(' ');
      }
    };
  });
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').filter('eventDescription', function() {
    return function(event) {
      switch (event.action) {
        case 'Catch':
          return event.passer + ' to ' + event.receiver;
        case 'Drop':
          return event.receiver + ' dropped from ' + event.passer;
        case 'Throwaway':
          if (event.type === 'Offense') {
            return event.passer + ' throwaway';
          } else {
            return 'Opponent throwaway';
          }
        case 'Stall':
          return event.passer + ' stalled';
        case 'MiscPenalty':
          return event.passer + ' penalized (caused turnover)';
        case 'D':
          return 'D by ' + event.defender;
        case 'Pull':
          return 'Pull by ' + event.defender;
        case 'PullOb':
          return 'Pull (Out of Bounds) by ' + event.defender;
        case 'Goal':
          if (event.type === 'Offense') {
            return 'Our Goal (' + event.passer + ' to ' + event.receiver + ')';
          } else {
            return 'Their Goal';
          }
        case 'Callahan':
          return 'Our Callahan (' + event.defender + ')';
        case 'EndOfFirstQuarter':
          return 'End of 1st Quarter';
        case 'EndOfThirdQuarter':
          return 'End of 3rd Quarter';
        case 'EndOfFourthQuarter':
          return 'End of 4th Quarter';
        case 'EndOfOvertime':
          return 'End of an Overtime';
        case 'Halftime':
          return 'Halftime';
        case 'GameOver':
          return 'Game Over';
        case 'Timeout':
          return 'Timeout';
        default:
          return event.action;
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').filter('eventImageUrl', function() {
    return function(event) {
      var url;
      url = 'images/cuties/';
      switch (event.action) {
        case 'Catch':
          url += 'big_smile.png';
          break;
        case 'Drop':
          url += 'eyes_droped.png';
          break;
        case 'Throwaway':
          url += event.type === 'Offense' ? 'shame.png' : 'exciting.png';
          break;
        case 'Stall':
          url += 'shame.png';
          break;
        case 'MiscPenalty':
          url += 'shame.png';
          break;
        case 'D':
          url += 'electric_shock.png';
          break;
        case 'Pull':
          url += 'nothing.png';
          break;
        case 'PullOb':
          url += 'what.png';
          break;
        case 'Goal':
          url += event.type === 'Offense' ? 'super_man.png' : 'cry.png';
          break;
        case 'Callahan':
          url += 'victory.png';
          break;
        case 'EndOfFirstQuarter':
          url += 'stopwatch1.png';
          break;
        case 'EndOfThirdQuarter':
          url += 'stopwatch1.png';
          break;
        case 'EndOfFourthQuarter':
          url += 'stopwatch1.png';
          break;
        case 'EndOfOvertime':
          url += 'stopwatch1.png';
          break;
        case 'Halftime':
          url += 'stopwatch1.png';
          break;
        case 'GameOver':
          url += 'finishflag.png';
          break;
        case 'Timeout':
          url += 'stopwatch1.png';
          break;
        default:
          url += 'money.png';
      }
      return url;
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').filter('hundredths', function() {
    return function(input) {
      if (_(input).isNaN()) {
        return '*';
      } else if (_(input).isNumber()) {
        return parseFloat(input.toFixed(2)).toLocaleString();
      } else {
        return 'NA';
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').filter('linePlayers', function() {
    return function(input) {
      if (input.length <= 1) {
        return "" + (input.join()) + " played";
      } else {
        return "" + (input.slice(0, -1).join(', ')) + " and " + (_.last(input)) + " played together";
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').filter('statSort', function($rootScope) {
    return function(input, type, reverse) {
      var copy, factor;
      if (!input) {
        return Math.random();
      }
      copy = _.clone(input);
      factor = reverse ? 1 : -1;
      return copy.sort(function(playerA, playerB) {
        var diff, nameToSortA, nameToSortB, statA, statB;
        if (type !== 'name') {
          statA = _.isNaN(playerA.stats[type]) ? -9999999 : playerA.stats[type];
          statB = _.isNaN(playerB.stats[type]) ? -9999999 : playerB.stats[type];
          diff = statA - statB;
          return diff * factor;
        } else {
          nameToSortA = $rootScope.getName(playerA.name, 'last') || $rootScope.getName(playerA.name, 'first');
          nameToSortB = $rootScope.getName(playerB.name, 'last') || $rootScope.getName(playerB.name, 'first');
          if (nameToSortA < nameToSortB) {
            return factor;
          } else if (nameToSortA > nameToSortB) {
            return factor * -1;
          }
        }
      });
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').filter('upperCase', function() {
    return function(input) {
      if (_(input).isString()) {
        return input.slice(0, 1).toUpperCase() + input.slice(1);
      }
    };
  });

}).call(this);
;d3.sankey = function() {
  var sankey = {},
      nodeWidth = 24,
      nodePadding = 8,
      size = [1, 1],
      nodes = [],
      links = [];

  sankey.nodeWidth = function(_) {
    if (!arguments.length) return nodeWidth;
    nodeWidth = +_;
    return sankey;
  };

  sankey.nodePadding = function(_) {
    if (!arguments.length) return nodePadding;
    nodePadding = +_;
    return sankey;
  };

  sankey.nodes = function(_) {
    if (!arguments.length) return nodes;
    nodes = _;
    return sankey;
  };

  sankey.links = function(_) {
    if (!arguments.length) return links;
    links = _;
    return sankey;
  };

  sankey.size = function(_) {
    if (!arguments.length) return size;
    size = _;
    return sankey;
  };

  sankey.layout = function(iterations) {
    computeNodeLinks();
    computeNodeValues();
    computeNodeBreadths();
    computeNodeDepths(iterations);
    computeLinkDepths();
    return sankey;
  };

  sankey.relayout = function() {
    computeLinkDepths();
    return sankey;
  };

  sankey.link = function() {
    var curvature = .5;

    function link(d) {
      var x0 = d.source.x + d.source.dx,
          x1 = d.target.x,
          xi = d3.interpolateNumber(x0, x1),
          x2 = xi(curvature),
          x3 = xi(1 - curvature),
          y0 = d.source.y + d.sy + d.dy / 2,
          y1 = d.target.y + d.ty + d.dy / 2;
      return "M" + x0 + "," + y0
           + "C" + x2 + "," + y0
           + " " + x3 + "," + y1
           + " " + x1 + "," + y1;
    }

    link.curvature = function(_) {
      if (!arguments.length) return curvature;
      curvature = +_;
      return link;
    };

    return link;
  };

  // Populate the sourceLinks and targetLinks for each node.
  // Also, if the source and target are not objects, assume they are indices.
  function computeNodeLinks() {
    _(nodes).each(function(node) {
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    _(links).each(function(link) {
      var source = link.source,
          target = link.target;
      if (typeof source === "number") source = link.source = nodes[link.source];
      if (typeof target === "number") target = link.target = nodes[link.target];
      source.sourceLinks.push(link);
      target.targetLinks.push(link);
    });
  }

  // Compute the value (size) of each node by summing the associated links.
  function computeNodeValues() {
    _(nodes).each(function(node) {
      node.value = Math.max(
        d3.sum(node.sourceLinks, value),
        d3.sum(node.targetLinks, value)
      );
    });
  }

  // Iteratively assign the breadth (x-position) for each node.
  // Nodes are assigned the maximum breadth of incoming neighbors plus one;
  // nodes with no incoming links are assigned breadth zero, while
  // nodes with no outgoing links are assigned the maximum breadth.
  function computeNodeBreadths() {
    var remainingNodes = nodes,
        nextNodes,
        x = 0;

    while (remainingNodes.length) {
      nextNodes = [];
      _(remainingNodes).each(function(node) {
        node.x = x;
        node.dx = nodeWidth;
        _(node.sourceLinks).each(function(link) {
          nextNodes.push(link.target);
        });
      });
      remainingNodes = nextNodes;
      ++x;
    }

    //
    moveSinksRight(x);
    scaleNodeBreadths((size[0] - nodeWidth) / (x - 1));
  }

  function moveSourcesRight() {
    _(nodes).each(function(node) {
      if (!node.targetLinks.length) {
        node.x = d3.min(node.sourceLinks, function(d) { return d.target.x; }) - 1;
      }
    });
  }

  function moveSinksRight(x) {
    _(nodes).each(function(node) {
      if (!node.sourceLinks.length) {
        node.x = x - 1;
      }
    });
  }

  function scaleNodeBreadths(kx) {
    _(nodes).each(function(node) {
      node.x *= kx;
    });
  }

  function computeNodeDepths(iterations) {
    var nodesByBreadth = d3.nest()
        .key(function(d) { return d.x; })
        .sortKeys(d3.ascending)
        .entries(nodes)
        .map(function(d) { return d.values; });

    //
    initializeNodeDepth();
    resolveCollisions();
    for (var alpha = 1; iterations > 0; --iterations) {
      relaxRightToLeft(alpha *= .99);
      resolveCollisions();
      relaxLeftToRight(alpha);
      resolveCollisions();
    }

    function initializeNodeDepth() {
      var ky = d3.min(nodesByBreadth, function(nodes) {
        return (size[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value);
      });

      _(nodesByBreadth).each(function(nodes) {
        _(nodes).each(function(node, i) {
          node.y = i;
          node.dy = node.value * ky;
        });
      });

      _(links).each(function(link) {
        link.dy = link.value * ky;
      });
    }

    function relaxLeftToRight(alpha) {
      _(nodesByBreadth).each(function(nodes, breadth) {
        _(nodes).each(function(node) {
          if (node.targetLinks.length) {
            var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);
            node.y += (y - center(node)) * alpha;
          }
        });
      });

      function weightedSource(link) {
        return center(link.source) * link.value;
      }
    }

    function relaxRightToLeft(alpha) {
      _(nodesByBreadth.slice().reverse()).each(function(nodes) {
        _(nodes).each(function(node) {
          if (node.sourceLinks.length) {
            var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);
            node.y += (y - center(node)) * alpha;
          }
        });
      });

      function weightedTarget(link) {
        return center(link.target) * link.value;
      }
    }

    function resolveCollisions() {
      _(nodesByBreadth).each(function(nodes) {
        var node,
            dy,
            y0 = 0,
            n = nodes.length,
            i;

        // Push any overlapping nodes down.
        nodes.sort(ascendingDepth);
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          dy = y0 - node.y;
          if (dy > 0) node.y += dy;
          y0 = node.y + node.dy + nodePadding;
        }

        // If the bottommost node goes outside the bounds, push it back up.
        dy = y0 - nodePadding - size[1];
        if (dy > 0) {
          y0 = node.y -= dy;

          // Push any overlapping nodes back up.
          for (i = n - 2; i >= 0; --i) {
            node = nodes[i];
            dy = node.y + node.dy + nodePadding - y0;
            if (dy > 0) node.y -= dy;
            y0 = node.y;
          }
        }
      });
    }

    function ascendingDepth(a, b) {
      return a.y - b.y;
    }
  }

  function computeLinkDepths() {
    _(nodes).each(function(node) {
      node.sourceLinks.sort(ascendingTargetDepth);
      node.targetLinks.sort(ascendingSourceDepth);
    });
    _(nodes).each(function(node) {
      var sy = 0, ty = 0;
      _(node.sourceLinks).each(function(link) {
        link.sy = sy;
        sy += link.dy;
      });
      _(node.targetLinks).each(function(link) {
        link.ty = ty;
        ty += link.dy;
      });
    });

    function ascendingSourceDepth(a, b) {
      return a.source.y - b.source.y;
    }

    function ascendingTargetDepth(a, b) {
      return a.target.y - b.target.y;
    }
  }

  function center(node) {
    return node.y + node.dy / 2;
  }

  function value(link) {
    return link.value;
  }

  return sankey;
};;'use strict';

angular.module('newBetaApp')
  .service('Authorization', ['$q', '$location', 'api',function($q, $location, api) {
    return {
      ping: function(teamId){
        var deferred = $q.defer();
        api.retrieveTeam(teamId, false,
          function() {
            deferred.resolve();
          },
          function(error) {
            $location.replace()
            if (error.status === 401){
              $location.url(teamId + '/login');
            } else {
              $location.url('/404');
            }
            deferred.reject(error);
          }
        );
        return deferred.promise;
      }
    };
  }]);;/* global _ */

'use strict';

angular.module('newBetaApp')
  .factory('allGames', ['$q', '$routeParams', 'api', function($q, $routeParams, api) {
    var deferred = $q.defer();
    api.retrieveGamesData($routeParams.teamId,
      function success(response) {
        _.each(response, function(game) {
          game.date = new Date(game.msSinceEpoch);
          if (game.pointsJson){
            game.points = JSON.parse(game.pointsJson);
          }
          delete game.pointsJson;
        });
        deferred.resolve(_.indexBy(response, 'gameId'));
      },
      function failure(e) {
        deferred.reject(e);
      }
    );
    return deferred.promise;
  }]);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').factory('broadcastApi', function($http, $routeParams) {
    var baseUrl;
    baseUrl = "http://127.0.0.1:8080/broadcast";
    return {
      getEvents: function() {
        return $http.get("" + baseUrl + "/" + $routeParams.teamId + "/events");
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').factory('calculationExplanations', function() {
    return _.indexBy(UltiAnalytics.explanations, "name");
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').factory('downloadUrl', [
    '$routeParams', 'api', function($routeParams, api) {
      return api.urlForStatsExportFileDownload($routeParams.teamId, null);
    }
  ]);

}).call(this);
;/* global _ */

'use strict';

angular.module('newBetaApp')
  .factory('filter', ['allGames',function (allGames) {
    var includedGames = [];
    function exclude(game){
      var index = _.indexOf(includedGames, game);
      index > -1 && includedGames.splice(index, 1);
    }
    function include(game){
      if (!_.contains(includedGames, game))
        includedGames.push(game);
    }
    function onlyInclude(games){
      includedGames.splice(0, includedGames.length);
      _.each(games, include);
    }
    allGames.then(function(response){
      allGames = response;
      onlyInclude(response);
    });
    return {
      includeAll: function(){onlyInclude(allGames)},
      included: includedGames,
      include: function(games){
        (_.isArray(games) || !games.gameId) ? _.each(games, include) : include(games);
      },
      onlyInclude: onlyInclude,
      exclude: function(games){
        if (_.isArray(games) || !games.gameId) {_.each(games, exclude);}
        else {exclude(games);}
      },
      contains: function(game){
        return _(includedGames).contains(game);
      }
    };
  }]);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').factory('gameStats', [
    '$q', 'allGames', 'playerStats', function($q, allGames, playerStats) {
      var api, deferred;
      deferred = $q.defer();
      $q.all([allGames, playerStats]).then(function(response) {
        allGames = response[0];
        playerStats = response[1];
        return deferred.resolve(api);
      });
      api = {};
      api.getFor = function(game) {
        var leaders, players, relevant, results;
        results = {};
        playerStats.setGames([game]);
        players = playerStats.getAll();
        relevant = _.where(allGames, {
          opponentName: game.opponentName
        });
        if (!_(relevant).isArray()) {
          relevant = [relevant];
        }
        results.record = _.countBy(relevant, function(game) {
          if (game.ours > game.theirs) {
            return 'wins';
          } else {
            return 'losses';
          }
        });
        _(results.record).defaults({
          wins: 0,
          losses: 0
        });
        leaders = {};
        _(['goals', 'assists', 'ds', 'throwaways', 'plusMinus']).each(function(type) {
          return leaders[type] = _.max(players, function(player) {
            return player.stats[type];
          });
        });
        results.leaders = leaders;
        return results;
      };
      return deferred.promise;
    }
  ]);

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  angular.module('newBetaApp').factory('LineView', function(Line) {
    var LineView;
    LineView = (function() {
      function LineView() {
        this.selectedAddPlayer = __bind(this.selectedAddPlayer, this);
        this.selectedLine = null;
        this.lines = {};
      }

      LineView.prototype.addLine = function(silent) {
        var line;
        line = new Line;
        this.lines[line.id] = line;
        if (!silent) {
          this.selectedLine = line;
        }
        return line;
      };

      LineView.prototype.removeLine = function(line) {
        return delete this.lines[line.id];
      };

      LineView.prototype.selectLine = function(line) {
        return this.selectedLine = line;
      };

      LineView.prototype.isSelectedLine = function(line) {
        return this.selectedLine === line;
      };

      LineView.prototype.selectedAddPlayer = function(player) {
        return this.selectedLine.addPlayers(player);
      };

      LineView.prototype.numberOfLines = function() {
        return _.keys(this.lines).length;
      };

      LineView.prototype.updateStats = function() {
        return _.each(this.lines, function(line) {
          return line.updateStats();
        });
      };

      return LineView;

    })();
    return LineView;
  });

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  angular.module('newBetaApp').factory('Line', [
    'lineStats', function(lineStats) {
      var Line, lineNum;
      lineStats.then(function(response) {
        return lineStats = response;
      });
      lineNum = 0;
      return Line = (function() {
        Line.prototype.getPlayers = function() {
          return this.players;
        };

        function Line() {
          this.addPlayers = __bind(this.addPlayers, this);
          this.stats = {};
          this.id = ++lineNum;
          this.players = [];
        }

        Line.prototype.addPlayers = function(players) {
          if (this.players.length < 7) {
            if (!_(players).isArray()) {
              players = [players];
            }
            this.players = _.union(this.players, players);
            return this.updateStats();
          }
        };

        Line.prototype.removePlayer = function(player) {
          this.players = _.without(this.players, player);
          return this.updateStats();
        };

        Line.prototype.updateStats = function() {
          return this.stats = lineStats.getStats(this.players);
        };

        return Line;

      })();
    }
  ]);

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').factory('lineStats', [
    '$q', 'filter', 'teamStats', 'utils', function($q, filter, teamStats, utils) {
      var api, countEvent, deferred, getAllPoints, getBubbleMapStats, getConnectionStats, getConsideredPoints, getDatafulPlayers, getPointSpread, makeChild;
      deferred = $q.defer();
      teamStats.then(function(response) {
        teamStats = response;
        return deferred.resolve(api);
      });
      getConsideredPoints = function(games, players) {
        var consideredPoints;
        consideredPoints = [];
        _.each(games, function(game) {
          return _(game.points).filter().each(function(point) {
            if (_.intersection(point.line, players).length === players.length) {
              return consideredPoints.push(point);
            }
          });
        });
        return consideredPoints;
      };
      getDatafulPlayers = function(points, players) {
        return _.reduce(points, function(map, point) {
          _.each(point.line, function(player) {
            return map[player] = true;
          });
          return map;
        }, {});
      };
      getConnectionStats = function(points, players) {
        var combinations;
        if (players.length < 2) {
          return false;
        }
        combinations = {};
        _.each(points, function(point) {
          return _.each(point.events, function(event) {
            var connectionRef, _name, _name1;
            if (_(players).contains(event.passer) && _(players).contains(event.receiver)) {
              connectionRef = combinations[_name = "Outcomes of " + event.passer + " throwing to " + event.receiver] != null ? combinations[_name] : combinations[_name] = {
                total: 0
              };
              if (connectionRef[_name1 = event.action] == null) {
                connectionRef[_name1] = 0;
              }
              connectionRef[event.action]++;
              return connectionRef.total++;
            }
          });
        });
        if (_.keys(combinations).length === 0) {
          return 'none';
        }
        return combinations;
      };
      getPointSpread = function(points) {
        var spread;
        spread = _(points).filter().countBy(function(point) {
          if (point.events[point.events.length - 1].type === 'Offense') {
            return 'ours';
          } else {
            return 'theirs';
          }
        }).valueOf();
        if (spread.ours == null) {
          spread.ours = 0;
        }
        if (spread.theirs == null) {
          spread.theirs = 0;
        }
        return spread;
      };
      getAllPoints = function(games) {
        return _.reduce(games, function(total, game) {
          return total.concat(game.points);
        }, []);
      };
      makeChild = function(name, countedEvents) {
        var box;
        box = {
          playerName: name,
          isPlayer: true,
          value: 0,
          stats: {}
        };
        _.each(countedEvents, function(name) {
          return box.stats[name] = 0;
        });
        return box;
      };
      countEvent = function(player, eventType) {
        player.stats[eventType]++;
        return player.value++;
      };
      getBubbleMapStats = function(points, players) {
        var bubbleStats, children, countedEvents, num, numberOfFillers, playersLookup, _i;
        countedEvents = ['Throwaway', 'Catch', 'Goal', 'D', 'Assist'];
        children = _.reduce(players, function(boxes, player) {
          boxes[player] = makeChild(player, countedEvents);
          return boxes;
        }, {});
        children.team = makeChild('Average', countedEvents);
        children.team.isPlayer = false;
        playersLookup = _.reduce(players, function(obj, player) {
          obj[player] = true;
          return obj;
        }, {});
        _.each(points, function(point) {
          return _.each(point.events, function(event) {
            if (_(countedEvents).contains(event.action)) {
              if (event.action === 'Throwaway') {
                if (playersLookup[event.passer]) {
                  return countEvent(children[event.passer], 'Throwaway');
                } else {
                  return countEvent(children.team, 'Throwaway');
                }
              } else if (event.action === 'Goal') {
                if (playersLookup[event.passer]) {
                  countEvent(children[event.passer], 'Assist');
                } else {
                  countEvent(children.team, 'Assist');
                }
                if (playersLookup[event.receiver]) {
                  return countEvent(children[event.receiver], 'Goal');
                } else {
                  return countEvent(children.team, 'Goal');
                }
              } else if (event.action === 'D') {
                if (playersLookup[event.defender]) {
                  return countEvent(children[event.defender], 'D');
                } else {
                  return countEvent(children.team, 'D');
                }
              } else if (event.action === 'Catch') {
                if (playersLookup[event.receiver]) {
                  return children[event.receiver].value++;
                } else {
                  return children.team.value++;
                }
              }
            }
          });
        });
        numberOfFillers = 6 - _.keys(children).length;
        children.team.value = children.team.value / 7;
        _.each(children, function(child) {
          return child.stats = _.reduce(child.stats, function(arr, val, name) {
            arr.push({
              label: name,
              value: val
            });
            return arr;
          }, []);
        });
        bubbleStats = {
          children: utils.objToArr(children)
        };
        for (num = _i = 0; 0 <= numberOfFillers ? _i <= numberOfFillers : _i >= numberOfFillers; num = 0 <= numberOfFillers ? ++_i : --_i) {
          bubbleStats.children.push(_.clone(children.team));
        }
        _.each(bubbleStats.children, function(child) {
          child.id = Math.random().toString().slice(2);
          return child.value = Math.pow(child.value, 3);
        });
        return bubbleStats;
      };
      api = {
        getStats: function(players) {
          var consideredPoints, dPoints, oPoints, pointSpread, results;
          consideredPoints = getConsideredPoints(filter.included, players);
          consideredPoints = _.filter(consideredPoints);
          oPoints = _.filter(consideredPoints, function(point) {
            return point.summary.lineType === 'O';
          });
          dPoints = _.filter(consideredPoints, function(point) {
            return point.summary.lineType === 'D';
          });
          pointSpread = getPointSpread(consideredPoints);
          results = {
            numberOfPointsConsidered: consideredPoints.length,
            pointsPossible: getAllPoints(filter.included).length,
            teamStats: {
              conversionRate: "" + (teamStats.getConversionRate(consideredPoints, pointSpread.ours)) + "%",
              pointSpread: "" + (pointSpread.ours || 0) + " - " + (pointSpread.theirs || 0),
              oProductivity: "" + (teamStats.getProductivity(consideredPoints, 'Offense') || 'NA') + "%",
              dProductivity: "" + (teamStats.getProductivity(consideredPoints, 'Defense') || 'NA') + "%"
            },
            connectionStats: getConnectionStats(consideredPoints, players),
            bubbleStats: getBubbleMapStats(consideredPoints, players),
            datafulPlayers: getDatafulPlayers(consideredPoints, players)
          };
          return results;
        },
        getForTeam: function() {
          var consideredPoints, pointSpread;
          consideredPoints = getAllPoints(filter.included);
          consideredPoints = _.filter(consideredPoints);
          pointSpread = getPointSpread(consideredPoints);
          return {
            conversionRate: "" + (teamStats.getConversionRate(consideredPoints, pointSpread.ours)) + "%",
            pointSpread: "" + (pointSpread.ours || 0) + " - " + (pointSpread.theirs || 0),
            oProductivity: "" + (teamStats.getProductivity(consideredPoints, 'Offense') || 'NA') + "%",
            dProductivity: "" + (teamStats.getProductivity(consideredPoints, 'Defense') || 'NA') + "%"
          };
        }
      };
      return deferred.promise;
    }
  ]);

}).call(this);
;'use strict';

angular.module('newBetaApp')
  .factory('next', function() {
    var next = '';
    return {
      get: function() {
        var temp = next;
        next = '';
        return temp;
      },
      set: function(val) {
        next = val;
      }
    };
  });;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').factory('playerExtensionStats', [
    '$q', 'allGames', function($q, allGames) {
      var api, consideredGames, deferred, playerName;
      playerName = '';
      consideredGames = [];
      api = {
        setGames: function(games) {
          return consideredGames = games;
        },
        setPlayer: function(name) {
          return playerName = name;
        },
        getTargetMap: function() {
          var actions, children, playersThrows;
          children = [];
          playersThrows = [];
          _.each(consideredGames, function(game) {
            return _.each(game.points, function(point) {
              return _.each(point.events, function(event) {
                if (event.passer === playerName) {
                  return playersThrows.push(event);
                }
              });
            });
          });
          actions = _.groupBy(playersThrows, 'action');
          _.each(actions, function(events, action) {
            var receivers;
            receivers = _.countBy(events, function(event) {
              return event.receiver || 'The Other Team';
            });
            return _.each(receivers, function(count, player) {
              return children.push({
                actionType: action,
                receiver: player,
                value: count
              });
            });
          });
          return {
            children: children
          };
        }
      };
      allGames.then(function(response) {
        allGames = response;
        return deferred.resolve(api);
      });
      deferred = $q.defer();
      return deferred.promise;
    }
  ]);

}).call(this);
;/* global _ */

'use strict';

angular.module('newBetaApp')
  .factory('playerStats', ['$q', 'allGames', 'team',function($q, allGames, team) {

    var includedGames;
    var playerStats;
    var basicStatTypes = ['catches', 'drops', 'throwaways', 'stalls', 'penalized', 'ds', 'iBPulls', 'oBPulls', 'goals', 'callahans', 'thrownCallahans', 'assists', 'passesDropped', 'completions', 'timePlayed', 'pullHangtime', 'gamesPlayed', 'dPoints', 'oPoints', 'oPlusMinus', 'dPlusMinus','hungPulls', 'oEfficiencyPoints', 'dEfficiencyPoints'];


    function recordEvent(event, players) {
      var receiver = event.receiver;
      var passer = event.passer;
      var defender = event.defender;
      switch (event.action) {
      case 'Catch':
        players[receiver] && players[receiver].stats.catches++;
        players[passer] && players[passer].stats.completions++;
        break;
      case 'Drop':
        players[receiver] && players[receiver].stats.drops++;
        players[receiver] && players[receiver].stats.oPlusMinus--;
        players[passer] && players[passer].stats.passesDropped++;
        break;
      case 'Throwaway':
        players[passer] && players[passer].stats.throwaways++;
        players[passer] && players[passer].stats.oPlusMinus--;
        break;
      case 'Stall':
        players[passer] && players[passer].stats.stalls++;
        players[passer] && players[passer].stats.oPlusMinus--;
        break;
      case 'MiscPenalty':
        if (event.type === 'Offense'){
          players[passer] && players[passer].stats.penalized++;
        } else {
          players[defender] && players[defender].stats.penalized++;
        }
        break;
      case 'D':
        players[defender] && players[defender].stats.ds++;
        players[defender] && players[defender].stats.dPlusMinus++;
        break;
      case 'Pull':
        if (players[defender]){
          players[defender].stats.iBPulls++;
          if (event.details && event.details.hangtime) {
            players[defender].stats.hungPulls++;
            players[defender].stats.pullHangtime += (event.details.hangtime / 1000);
          }
        }
        break;
      case 'PullOb':
        if (players[defender]){
          players[defender].stats.oBPulls++;
        }
        break;
      case 'Goal':
        if (players[passer]){
          players[passer].stats.oPlusMinus++;
          players[passer].stats.completions++;
          players[passer].stats.assists++;
        }
        if (players[receiver]){
          players[receiver].stats.oPlusMinus++;
          players[receiver].stats.catches++;
          players[receiver].stats.goals++;
        }
        break;
      case 'Callahan':
        if (players[defender]){
          players[defender].stats.catches++;
          players[defender].stats.dPlusMinus++;
          players[defender].stats.oPlusMinus++;
          players[defender].stats.goals++;
          players[defender].stats.ds++;
          players[defender].stats.callahans++;
        }
        break;
      default:
        if (['EndOfFirstQuarter', 'Halftime', 'EndOfThirdQuarter', 'EndOfFourthQuarter', 'GameOver', 'EndOfOvertime'].indexOf(event.action) < 0){
          console.log('Invalid event: ' + event.action + ' (event skipped)');
        }
      }
    }

    function establishPlayerBuckets(players, basicStatTypes){
      var playerBuckets = {}

      return playerBuckets;
    }
    function defaultBucket(basicStatTypes){
      var bucket = {
        stats: {}
      };
      _.each(basicStatTypes, function(type){
        bucket.stats[type] = 0;
      });
      return bucket;
    }
    function pointWasWon(point){
      return _.last(point.events).type === 'Offense';
    }

    var derive = function() {
      var shittyMode = true; // see ULTIWEB-71. @TODO
      var players = {}
      _(team.players).pluck('name').each(function(name){
        players[name] = defaultBucket(basicStatTypes);
      });
      _.each(includedGames, function(ref) {
        var playedInGame = {};
        _.each(allGames[ref.gameId].points, function(point) {
          var subbedPlayers = _.reduce(point.substitutions, function(subbedPlayers, substitution){
            return subbedPlayers.concat([substitution.fromPlayer, substitution.toPlayer]);
          }, []);
          var involvedPlayers = _.union(point.line, subbedPlayers);
          _.each(involvedPlayers, function(name){
            if (shittyMode && !players[name]){
              players[name] = defaultBucket(basicStatTypes);
            }
            if (players[name]) {
              if (!playedInGame[name]){
                players[name].stats.gamesPlayed++;
                playedInGame[name] = true;
              }
              point.summary.lineType === 'D' ? players[name].stats.dPoints++ : players[name].stats.oPoints++;
              players[name].stats.timePlayed += _.contains(subbedPlayers, name) ? (point.endSeconds - point.startSeconds) / 2 : point.endSeconds - point.startSeconds;
            }
          //           for (var i = 0; i < point.substitutions.length; i++) {
          // var fromPlayer = point.substitutions[i].fromPlayer;
          // var toPlayer = point.substitutions[i].toPlayer;
          });
          if (pointWasWon(point)){
            _.each(involvedPlayers, function(name){
              point.summary.lineType === 'D' ? players[name].stats.dEfficiencyPoints++ : players[name].stats.oEfficiencyPoints++;
            });
          } else {
            _.each(involvedPlayers, function(name){
              point.summary.lineType === 'D' ? players[name].stats.dEfficiencyPoints-- : players[name].stats.oEfficiencyPoints--;
            });
          }
          _.each(point.events, function(event){
            recordEvent(event, players);
          });
        });
      });
      _.each(players, function(player){
        extendPercentageStats(player.stats);
      });
      _.each(players, function(player, name){
        player.name = name;
      });
      _.each(players, function(player){
        extendAestheticStats(player.stats);
      });
      playerStats = players;
      return players;
    };
    function statSum(stats, types, negative){
      return _.reduce(types, function(memo,type){
        memo = negative ? memo - stats[type] : memo + stats[type];
        return memo;
      }, 0);
    }
    function extendAestheticStats(stats){
      stats.pointsPlayed = statSum(stats, ['oPoints', 'dPoints']);
      stats.pulls = statSum(stats, ['oBPulls', 'iBPulls']);
      stats.touches = statSum(stats, ['completions', 'throwaways', 'goals','passesDropped']);
      stats.plusMinus = statSum(stats, ['oPlusMinus', 'dPlusMinus']);
      stats.minutesPlayed = Math.round(stats.timePlayed / 60);
      stats.averagePullHangtime = stats.pullHangtime  / stats.hungPulls;
      stats.oEfficiency = stats.oEfficiencyPoints / stats.oPoints;
      stats.dEfficiency = stats.dEfficiencyPoints / stats.dPoints;
      stats.efficiency = (stats.oEfficiencyPoints + stats.dEfficiencyPoints) / stats.pointsPlayed;
      _.each(['goals', 'assists', 'ds',  'throwaways',  'drops'], function(name){
        stats['pp' + name[0].toUpperCase() + name.slice(1)] = stats.pointsPlayed ? (stats[name] / stats.pointsPlayed) : 0;
      });
    }
    function extendPercentageStats(stats){
      _.each([
          ['catchingPercentage', 'catches', 'drops'],
          ['passingPercentage', 'completions', 'throwaways'],
          ['iBPullingPercentage', 'iBPulls', 'oBPulls']
        ], function(averageProperities){
          stats[averageProperities[0]] = Math.round(stats[averageProperities[1]] / (stats[averageProperities[1]] + stats[averageProperities[2]]) * 100);
        }
      );
    }
    function getLeaders(types){
      var leaders = {};
      _.each(types, function(type){
        leaders[type] = _.max(playerStats,function(player){
          return player.stats[type];
        });
      });
      return leaders;
    }
    function getTotals(){
      var totals = {};
      _.each(basicStatTypes, function(type){
        totals[type] = _.reduce(playerStats,getSumFunction(type),0);
      });
      extendPercentageStats(totals);
      extendAestheticStats(totals);
      return totals;
    }
    function getAverages(){
      var averages = {};
      var statTypes = _.keys(_.sample(playerStats).stats);
      _(statTypes).each(function(type){
        var numberOfNans = _.reduce(playerStats, function(count, player){
          if (_.isNaN(player.stats[type]))
            count++;
          return count;
        },0)
        averages[type] = _.reduce(playerStats, getSumFunction(type),0).valueOf() / (_.keys(playerStats).length - numberOfNans);
      });
      return averages;
    }
    function getSumFunction(type){
      return function(memo, player){
        if (_.isNumber(memo)) {
          return player.stats[type] ? memo + player.stats[type] : memo;
        }
      };
    }

    //promise land
    $q.all([allGames, team]).then(function(responses){
      allGames = responses[0];
      team = responses[1];
      deferred.resolve({
        getLeaders: getLeaders,
        getTotals: getTotals,
        getAverages: getAverages,
        getAll: function(){
          return playerStats
        },
        getForPlayer: function(playerName){
          return playerStats[playerName];
        },
        setGames: function(games){
          includedGames = games;
          derive();
        }
      });
    });
    var deferred = $q.defer();
    return deferred.promise;
  }]);

// Assists Passes  Throwaways  Stalls  Percent Completed
// Goals Catches Touches Drops Percent Caught
// Games Played  PointsPlayed  Minutes Played  Offensive Points  Defensive Points
// D's Callahans Pulls Average Hang Time Out of Bounds Pulls
// Goals Assists Ds  Throwaways  Drops

;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').factory('relocate', [
    '$location', '$routeParams', function($location, $routeParams) {
      var base;
      base = $routeParams.teamId + '/';
      return {
        goTo: function(route, query) {
          return $location.path(base + route + '/' + decodeURIComponent(query));
        }
      };
    }
  ]);

}).call(this);
;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').factory('savedState', function() {
    var data;
    data = {};
    return {
      getOnce: function() {
        var temp;
        temp = data;
        data = {};
        return temp;
      },
      set: function(newData) {
        return _.extend(data, newData);
      }
    };
  });

}).call(this);
;'use strict';

angular.module('newBetaApp')
  .factory('team', ['$q', '$routeParams', '$rootScope','api',
    function($q, params,$rootScope, api) {
      var players = {};
      function getName(nickname, type){
        if (!players[nickname])
          return nickname;
        if ((type === 'full' || !type ) && (players[nickname].firstName && players[nickname].lastName))
          return players[nickname].firstName + ' ' + players[nickname].lastName;
        if (type === 'shortened' && players[nickname].firstName && players[nickname].lastName)
          return players[nickname].firstName.slice(0,1).toUpperCase() + '. ' + players[nickname].lastName;
        if (type === 'last' && players[nickname].firstName && players[nickname].lastName)
          return players[nickname].lastName.slice(0,1).toUpperCase()
        if (type === 'first' && players[nickname].firstName && players[nickname].lastName)
          return players[nickname].firstName.slice(0,1).toUpperCase()
        return players[nickname][type] || nickname;
      }
      $rootScope.getName = getName;
      var deferred = $q.defer();
      api.retrieveTeam(params.teamId, true,
        function success(result) {
          players = _.indexBy(result.players, 'name')
          $rootScope.$digest();
          deferred.resolve(result);
        },
        function failure(e) {
          deferred.reject(e);
        }
      );
      return deferred.promise;
    }
  ]);;'use strict';

angular.module('newBetaApp')
  .factory('teamName', ['$q', 'team',function ($q, team) {
    var deferred = $q.defer();
    team.then(function(result){
      deferred.resolve(result.nameWithSeason);
    });
    return deferred.promise;
  }]);
;/* global _*/

'use strict';

angular.module('newBetaApp')
  .factory('teamStats', ['$q', '$routeParams', '$rootScope', 'filter', 'api', 'allGames','teamName',function($q, $routeParams, $rootScope, filter, api, allGames, teamName) {
    var deferred = $q.defer();
    var statsMap = {};
    var collection = 0;
    var goal;
    $q.all([allGames, teamName]).then(function(response) {
      var games = response[0]
      teamName = response[1]
      goal = _.keys(games).length;
      _.each(games, function(game, id) {
        api.retrieveTeamStatsForGames($routeParams.teamId, [id],
          function success(result) {
            statsMap[id] = result;
            if (++collection === goal) {
              deferred.resolve(tsApi);
            }
          },
          function failure(e) {
            deferred.reject(e);
          }
        );
      });
    });

    function getGoalSummary(game){
      return statsMap[game.gameId].goalSummary;
    }
    function throwGroupingFunc(num) {
      if (num === 1) {
        return '1';
      }
      if (num < 4) {
        return '4';
      }
      if (num < 8) {
        return '8';
      }
      if (num < 12) {
        return '12';
      }
      return '12+';
    }

    function addLink(passer, receiver, map) {
      if (map.links[passer]) {
        if (map.links[passer][receiver]) {
          map.links[passer][receiver] += 1;
        } else {
          map.links[passer][receiver] = 1;
        }
      } else {
        map.links[passer] = {};
        map.links[passer][receiver] = 1;
      }
    }

    var tsApi = {
      getFromIncluded: function() {
        var that = this;
        var result = {};
        var temp = $rootScope.$new();
        temp.included = filter.included;
        temp.$watchCollection('included', function() {
          _.extend(result,that.getFrom(filter.included));
        });
        return result;
      },
      getFrom: function(games) {
        var results = {};
        var considerablePoints = _.reduce(games, function(points, game){
          return points.concat(game.points);
        }, []);
        considerablePoints = _.filter(considerablePoints)
        results.record = this.getRecord(games);
        results.pointSpread = this.getPointSpread(games);
        results.offensiveProductivity = this.getProductivity(considerablePoints, 'Offense');
        results.conversionRate = this.getConversionRate(considerablePoints, results.pointSpread.ours);
        results.throwsPerPossession = this.getThrowsPerPossession(considerablePoints);
        results.pointSummary = this.getPointSummary(considerablePoints);
        results.assistMap = this.getAssistMap(considerablePoints);
        results.windEfficiency = this.getWindEfficiency(games, results.pointSpread.ours);
        return results;
      },
      getWindEfficiency: function(games){
        var teamLookup = {
          us: teamName,
          them: 'Opponents'
        }
        var pointsIndexedByWind = _.reduce(games, function(memo, game){
          if (game.wind){
            memo[game.wind.mph] = memo[game.wind.mph] || [];
            memo[game.wind.mph] = memo[game.wind.mph].concat(game.points);
          }
          return memo;
        } , {})

        if (_.keys(pointsIndexedByWind).length < 5) return false;

        var _this = this
        var results = _.reduce(['us', 'them'], function(result, team){
          result[teamLookup[team]] = _.reduce(pointsIndexedByWind, function(memo, points, windSpeed){
            var pointSummary = _this.getPointSummary(_.filter(points))
            memo.push({
              x:windSpeed,
              y:_this.getConversionRate(_.filter(points), pointSummary[team].defense + pointSummary[team].offense )
            });
            return memo;
          }, [])
          return result;
        }, {});
        if ( !results[teamLookup.us].length ) return false;
        return results;
      },
      getProductivity: function(points, lineType, isOpponent){
        var offensiveOpps = 0;
        var offensiveConversions = 0;
        _(points).each(function(point) {
          if (point.summary.lineType === lineType.slice(0,1)) {
            offensiveOpps++;
            if (point.events[point.events.length - 1].type === lineType) {
              offensiveConversions++;
            }
          }
        });
        return offensiveOpps ? Math.round(offensiveConversions / offensiveOpps * 100) : 0;
      },
      getConversionRate: function(points, ourPointSpread){
        var scoringOpps = 0;
        _(points).filter().each(function(point) {
          if (point.summary.lineType === 'O') {
            scoringOpps++;
          }
          _(point.events).each(function(event) {
            if ((event.action === 'D' && event.type === 'Defense') || (event.action === 'Throwaway' && event.type === 'Defense')) {
              scoringOpps++;
            }
          });
        });
        return scoringOpps ? Math.round(ourPointSpread / scoringOpps * 100) : 0;
      },
      getPointSummary: function(points){
        var pointSummary = {
          us: {
            offense: 0,
            defense: 0
          },
          them: {
            offense: 0,
            defense: 0
          }
        };
        _(points).filter().each(function(point) {
          if (point.events[point.events.length - 1].type === 'Offense') {
            point.summary.lineType === 'D' ? pointSummary.us.defense++ : pointSummary.us.offense++;
          } else {
            point.summary.lineType === 'D' ? pointSummary.them.offense++ : pointSummary.them.defense++;
          }
        });
        return pointSummary;
      },
      getPointSpread: function(games){
        var pointSpread = {
          ours: 0,
          theirs: 0
        };
        _(games).each(function(game) {
          var goalSummary = getGoalSummary(game);
          pointSpread.ours += goalSummary.ourDlineGoals + goalSummary.ourOlineGoals;
          pointSpread.theirs += goalSummary.theirDlineGoals + goalSummary.theirOlineGoals;
        });
        return pointSpread;
      },
      getRecord: function(games){
        var record = {
          wins: 0,
          losses: 0
        };
        _(games).each(function(game) {
          var goalSummary = getGoalSummary(game);
          goalSummary.ourOlineGoals + goalSummary.ourDlineGoals > goalSummary.theirOlineGoals + goalSummary.theirDlineGoals ? record.wins++ : record.losses++;
        });
        return record;
      },
      getThrowsPerPossession: function(points){
        var scored = [];
        var failed = [];
        var passes = 0;
        _(points).each(function(point) {
          passes = 0;
          _(point.events).each(function(event) {
            if (event.type === 'Offense') {
              if (event.action === 'Catch') {
                passes++;
              } else if (event.action === 'Goal') {
                scored.push(++passes);
                passes = 0;
              } else if (event.action === 'Throwaway' || event.action === 'Drop' || event.action === 'Turnover' || event.action === 'Stall') {
                failed.push(++passes);
                passes = 0;
              }
            } else {
              if (passes > 0) {
                scored.push(passes);
                passes = 0;
              }
            }
          });
        });
        var throwsPerPossession = {};
        throwsPerPossession.scored = _.countBy(scored, throwGroupingFunc);
        throwsPerPossession.failed = _.countBy(failed, throwGroupingFunc);
        return throwsPerPossession;
      },
      getAssistMap: function(points){
        var assistMap = {nodes: {}, links: {}};
        _(points).each(function(point) {
          var endEvent = point.events[point.events.length - 1];
          var penultimateEvent = point.events[point.events.length - 2];
          if (endEvent.type === 'Offense') { // if the goal was scored by the offense.
            var passer = endEvent.passer + 'P';
            var receiver = endEvent.receiver + 'R';
            if (penultimateEvent && penultimateEvent.type === 'Offense') {
              var penUPasser = penultimateEvent.passer + 'H';
              assistMap.nodes[penUPasser] = true;
              addLink(penUPasser, passer, assistMap);
            }
            assistMap.nodes[passer] = true;
            assistMap.nodes[receiver] = true;
            addLink(passer, receiver, assistMap);
          }
        });
        var nodes = [];
        var i = 0;
        var map = {};
        _.each(assistMap.nodes, function(value, key) {
          map[key] = i;
          nodes[i] = {
            name: key
          };
          i++;
        });
        assistMap.nodes = nodes;
        var links = [];
        _.each(assistMap.links, function(receivers, thrower) {
          _.each(receivers, function(quantity, receiver) {
            links.push({
              source: map[thrower],
              target: map[receiver],
              value: quantity
            });
          });
        });
        assistMap.links = links;
        return assistMap;
      }
    };
    return deferred.promise;
  }]);




;/* global $, angular, jQuery */
// written by Jim Geppert

'use strict';

angular.module('newBetaApp')
  .service('api', function Rest($location) {
    var exports = {};
    // init the global app object
    var Ultimate = {};

    Ultimate.busyDialogStack = 0;

    // make sure we use the host from where we were loaded to prevent CORS from being used unnecessarily
    // (unless the page is loaded locally in which case just use the default host)
    var restHost = window.location.host.indexOf("ultimate-numbers.com") === -1 ? "www.ultianalytics.com" : "www.ultimate-numbers.com";
    Ultimate.baseRestUrl = "http://" + restHost + '/rest/view';

    // make sure we use the host from where we were loaded to prevent CORS from being used unnecessarily
    Ultimate.sessionId = new Date().getTime() + '';

    exports.retrieveState = function(teamId, stateId, stateType, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveState');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/state/' + stateType + '/' + stateId;
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    exports.saveState = function(teamId, stateType, data, successFunction, errorFunction) {
      sendAnalyticsEvent('saveState');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/state/' + stateType;
      sendRequest({
        url: url,
        dataType: 'json',
        isPost: true,
        data: data,
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    exports.retrieveTeam = function(id, includePlayers, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveTeam');
      var url = Ultimate.baseRestUrl + '/team/' + id;
      url = includePlayers ? url + '?players=true' : url;
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    function retrieveTeamForAdmin(id, includePlayers, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveTeamForAdmin');
      var url = Ultimate.baseRestUrl + '/admin/team/' + id;
      url = includePlayers ? url + '?players=true' : url;
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    exports.retrieveGames = function(teamId, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveGames');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/games';
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    exports.retrieveGamesData = function(teamId, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveGames');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/gamesdata';
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    function retrieveGamesForAdmin(teamId, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveGamesForAdmin');
      var url = Ultimate.baseRestUrl + '/admin/team/' + teamId + '/games';
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    exports.retrieveGame = function(teamId, gameId, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveGame');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/game/' + gameId;
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    function deleteGame(teamId, gameId, successFunction, errorFunction) {
      sendAnalyticsEvent('deleteGame');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/game/' + gameId + '/delete';
      sendRequest({
        url: url,
        dataType: 'json',
        isPost: true,
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    function deleteTeam(teamId, successFunction, errorFunction) {
      sendAnalyticsEvent('deleteTeam');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/delete';
      sendRequest({
        url: url,
        dataType: 'json',
        isPost: true,
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    function deletePlayer(teamId, playerToDelete, replacementPlayer, successFunction, errorFunction) {
      sendAnalyticsEvent('deletePlayer');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/player/delete?player=' + playerToDelete + '&replacement=' + replacementPlayer;
      sendRequest({
        url: url,
        dataType: 'json',
        isPost: true,
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    function renamePlayer(teamId, playerToRename, replacementPlayer, successFunction, errorFunction) {
      sendAnalyticsEvent('renamePlayer');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/player/rename?player=' + playerToRename + '&replacement=' + replacementPlayer;
      sendRequest({
        url: url,
        dataType: 'json',
        isPost: true,
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    exports.retrievePlayerStatsForGames = function(teamId, gameIds, successFunction, errorFunction) {
      sendAnalyticsEvent('retrievePlayerStatsForGames');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/stats/player';
      if (gameIds !== null && gameIds.length > 0) {
        url = url + '?gameIds=' + gameIds.join('_');
      }
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    exports.retrieveTeamStatsForGames = function(teamId, gameIds, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveTeamStatsForGames');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/stats/team';
      if (gameIds !== null && gameIds.length > 0) {
        url = url + '?gameIds=' + gameIds.join('_');
      }
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    exports.retrievePlayerStatsForEachGame = function(teamId, gameIds, successFunction, errorFunction) {
      sendAnalyticsEvent('retrievePlayerStatsForGames');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/stats/player/games';
      if (gameIds !== null && gameIds.length > 0) {
        url = url + '?gameIds=' + gameIds.join('_');
      }
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    exports.retrieveAllStatsForGames = function(teamId, gameIds, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveAllStatsForGames');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/stats/all';
      if (gameIds !== null && gameIds.length > 0) {
        url = url + '?gameIds=' + gameIds.join('_');
      }
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    function retrieveTeams(successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveTeams');
      var url = Ultimate.baseRestUrl + '/teams';
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    function retrievePlayerStatsForGame(options, successFunction, errorFunction) {
      sendAnalyticsEvent('retrievePlayerStatsForGame');
      var teamId = options.teamId;
      retrievePlayerStatsForGames(teamId, [options.gameId], successFunction, errorFunction);
    }

    function savePassword(teamId, password, successFunction, errorFunction) {
      sendAnalyticsEvent('savePassword');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/password/' + (isNullOrEmpty(password) ? 'REMOVE-PASSWORD' : password);
      sendRequest({
        url: url,
        dataType: 'json',
        isPost: true,
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    exports.signon = function(teamId, password, successFunction, errorFunction) {
            sendAnalyticsEvent('signon');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/authenticate/' + password;
      sendRequest({
        url: url,
        dataType: 'json',
        isPost: true,
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    exports.urlForStatsExportFileDownload = function(teamId, games) {
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/stats/export';
      if (games) {
        var sortedGames = sortGames(games);
        var gameIds = collectGameIds(sortedGames);
        if (gameIds !== null && gameIds.length > 0) {
          url = url + '?gameIds=' + gameIds.join('_');
        }
      }
      return url;
    };

    function urlForGameExportFileDownload(teamId, gameId) {
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/export/game/' + gameId + '?players=true';
      return url;
    }

    function urlForGameExportFileUpload(teamId) {
      var returnUrl = encodeURIComponent('/team/admin#teamgamespage?team=' + teamId);
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/import/game?return=' + returnUrl;
      return url;
    }

    function sendRequest(request) {
      var options = {
        success: function(data, textStatus, jqXHR) {
          busyDialogEnd();
          var responseTypeReceived = jqXHR.getResponseHeader('Content-Type');
          if (isExpectedResponseType(request, jqXHR)) {
            request.success(data, textStatus, jqXHR);
          } else {
            logRequestFailure(jqXHR, 'unexpected response type = ' + responseTypeReceived);
          }
        },
        error: function(jqXHR, textStatus, errorThrown) {
          busyDialogEnd();
          var error = logRequestFailure(jqXHR, textStatus, errorThrown);
          if (request.error) {
            request.error(jqXHR, textStatus, errorThrown);
          } else {
            throw error;
          }
        }
      };
      if (request.dataType) {
        options.dataType = request.dataType;
      }
      if (request.isPost) {
        options.type = 'POST';
        options.contentType = 'application/json';
      }
      if (request.data) {
        options.data = request.data;
      }
      busyDialogStart();
      Ultimate.sessionId = 'foo ';
      var url = addQueryStringParameter(request.url, 'cachebuster ', Ultimate.sessionId);
      options.xhrFields = {
        withCredentials: true
      };
      $.ajax(url, options);
    }

    function isExpectedResponseType(request, responseTypeReceived) {
      if (request.expectedResponseType) {
        if (responseTypeReceived.indexOf(request.expectedResponseType) < 0) {
          return false;
        }
      }
      return true;
    }

    function addCommas(nStr) {
      nStr += '';
      var x = nStr.split('.');
      var x1 = x[0];
      var x2 = x.length > 1 ? '.' + x[1] : '';
      var rgx = /(\d+)(\d{3})/;
      while (rgx.test(x1)) {
        x1 = x1.replace(rgx, '$1' + ',' + '$2');
      }
      return x1 + x2;
    }

    function logRequestFailure(jqXHR, textStatus, errorThrow) {
      var error = errorDescription(jqXHR, textStatus, errorThrow);
      logError(error);
      return error;
    }

    function errorDescription(jqXHR, textStatus, errorThrow) {
      return 'ERROR: status ' + jqXHR.status + ' (' + textStatus + ') ' + errorThrow + (jqXHR.responseText ? ' \n' + jqXHR.responseText : '');
    }

    function getParameterByName(name) {
      var parts = window.location.href.split('?'); // jQM seems to pass odd urls sometimes (previous qs before current qs)
      var queryString = '?' + parts[parts.length - 1];
      var match = new RegExp('[?&]' + name + '=([^&]*)').exec(queryString);
      var value = match && decodeURIComponent(match[1].replace(/\+/g, ' '));
      return value;
    }

    function logError(error) {
      if (window.console) {
        console.log(error);
      }
    }

    // descending date-ordered list
    function sortGames(games) {
      var sortedGames = games.sort(function(a, b) {
        var first = a.msSinceEpoch ? a.msSinceEpoch : 0;
        var second = b.msSinceEpoch ? b.msSinceEpoch : 0;
        return second - first;
      });
      return sortedGames;
    }

    function collectGameIds(games) {
      var gameIds = [];
      $.each(games, function() {
        gameIds.push(this.gameId);
      });
      return gameIds;
    }


    // answer an array of object: {id: '
    //             TOURNAMENT - Centex - 2012 ', name: '
    //             Centex ', year: 2012, games:['
    //             game1234 ', '
    //             game345 ']} in reverse chrono order
    function getTournaments(games) {
      var tournamentsList = [];
      if (games && games.length > 0) {
        var sortedGames = sortGames(games);
        var tournamentGames = {};

        jQuery.each(sortedGames, function() {
          var name = this.tournamentName;
          if (name) {
            var year = this.msSinceEpoch ? new Date(this.msSinceEpoch).getFullYear() : '';
            var id = 'TOURNAMENT - ' + name + ' - ' + year;
            if (!tournamentGames[id]) {
              tournamentGames[id] = [];
              tournamentsList.push({
                id: id,
                name: name,
                year: year
              });
            }
            tournamentGames[id].push(this.gameId);
          }
        });

        jQuery.each(tournamentsList, function() {
          this.games = tournamentGames[this.id];
        });

        return tournamentsList;
      }
      return [];
    }

    function getInternetExplorerVersion(){
    // Returns the version of Internet Explorer or a -1 (indicating the use of another browser).
      var rv = -1; // Return value assumes failure.
      if (navigator.appName == 'Microsoft Internet Explorer ') {
        var ua = navigator.userAgent;
        var re = new RegExp('MSIE([0 - 9] {1, }[\.0 - 9] {0, }) ');
        if (re.exec(ua) !== null) rv = parseFloat(RegExp.$1);
      }
      return rv;
    }

    function log(message) {
      if (window.console) {
        console.log(message);
      }
    }

    function isNullOrEmpty(s) {
      return s == null || jQuery.trim(s) == '';
    }

    function busyDialogStart() {
      Ultimate.busyDialogStack++;
      if (Ultimate.busyDialogStack == 1) {
        $('.hideWhenBusy ').addClass('hidden ');
        $('.spinner ').removeClass('hidden ');
      }
    }

    function busyDialogEnd() {
      Ultimate.busyDialogStack--;
      if (Ultimate.busyDialogStack == 0) {
        resetBusyDialog();
      }
    }

    function resetBusyDialog() {
      $('.spinner ').addClass('hidden ');
      showHiddenWhenBusyElements();
      Ultimate.busyDialogStack == 0;
    }

    /*
    Creates a canonical string representation of the object which can be used for comparison or subsequent hash creation.
    The object will be deeply recursed to find all objects.
    Circular references are handled automatically (an object will not be re-visited once it has been handled).
    Thread-safe (designed to be a singleton)
    */
    Ultimate.Canonicalizer = function() {
      /*
        Return a canonical string of the object.
        Undefined properties are skipped.
        options: {
        treatNullAsUndefined: boolean  By default NULL properties will be written.  To treat nulls like undefined specify treatNullAsUndefined
        treatEmptyStringsAsUndefined: boolean  By default empty string properties will be written.  To treat empty strings like undefined specify treatEmptyStringsAsUndefined
        <propertyName>: boolean   By default all other properties of an object are navigated.  To ignore a certain property add it to the options with value of true.
        */
      this.toCanonicalString = function(object, options) {
        var allProps = [];
        var visitedObjects = [];
        pushObject(object, allProps, options, 0, visitedObjects);
        return allProps.join('');
      };

      function pushObject(obj, allProps, options, level, visitedObjects) {
        if (typeof obj == 'object' && obj !== null) {
          var visitedReference = getVisitedReference(obj, visitedObjects);
          if (visitedReference) {
            allProps[allProps.length] = visitedReference;
          } else {
            visitedObjects.push(obj);
            var props = [];
            for (var prop in obj) {
              props.push(prop);
            }
            props = props.sort();
            for (var i = 0; i < props.length; i++) {
              var childObj = obj[props[i]];
              if (shouldPush(childObj, options, props[i])) {
                allProps[allProps.length] = '\n';
                for (var j = 0; j < level; j++) {
                  allProps[allProps.length] = '.';
                }
                allProps[allProps.length] = props[i];
                allProps[allProps.length] = ':';
                pushObject(childObj, allProps, options, level + 1, visitedObjects);
              }
            }
          }
        } else {
          allProps[allProps.length] = obj == null ? 'null' : obj;
        }
      }

      function shouldPush(value, options, propName) {
        if (propName && options[propName]) {
          return false;
        } else if (typeof value == 'function' || value === undefined) {
          return false;
        } else if (options.treatNullAsUndefined && value === null) {
          return false;
        } else if (options.treatEmptyStringsAsUndefined && value == '') {
          return false;
        }
        return true;
      }

      function getVisitedReference(object, visitedObjects) {
        for (var i = 0; i < visitedObjects.length; i++) {
          if (visitedObjects[i] === object) {
            return '@REF' + i;
          }
        }
        return null;
      }

    };

    function showHiddenWhenBusyElements() {
      $('.hideWhenBusy').removeClass('hidden');
    }

    function hideHiddenWhenBusyElements() {
      $('.hideWhenBusy').addClass('hidden');
    }

    function addQueryStringParameter(url, key, value) {
      return url + (url.indexOf('?') > 0 ? '&' : '?') + key + '=' + value;
    }

    function resetCacheBuster() {
      Ultimate.sessionId = new Date().getTime() + '';
    }

    function sendAnalyticsEvent(restEndpointName) {
      // NOTE: You can add another property for more detail
      if (typeof(_gaq) !== 'undefined' && _gaq.push)
        _gaq.push(['_trackEvent', Ultimate.isAdminSite ? 'WebRestRequest-Admin' : 'WebRestRequest', restEndpointName]);
    }

    function defaultError(e){
      throw e;
    }
    // AngularJS will instantiate a singleton by calling 'new' on this function
    return exports;
  });;// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  angular.module('newBetaApp').factory('utils', function() {
    return {
      objToArr: function(obj, keyName) {
        return _.reduce(obj, function(arr, chunk, key) {
          if (keyName) {
            chunk[keyName] = key;
          }
          arr.push(chunk);
          return arr;
        }, []);
      }
    };
  });

}).call(this);
;'use strict';

angular.module('newBetaApp')
  .factory('viewer', function ($rootScope) {
    $(window).resize(function(){
      $rootScope.$digest()
    });
    return {
      isMobile: function () {
        return /Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      },
      isMobileSized: function () {
        return $(window).outerWidth() <= 768;
      },
      isLargeScreen: function (){
        return $(window).outerWidth() >= 1200;
      }
    };
  });
;/****************  PLAYER STATS ACCUMULATOR ********************/

/*
	Summarizes raw game data for a team, producing the same player stats object that is
	returned by retrievePlayerStatsForGames(), AKA endpoint /team/{teamId}/stats/player.
	The game data should be in the same format as that returned by retrieveGamesData(),
	AKA /team/{teamId}/gamesdata.  That is, game objects with point data that is embedded JSON.

	Equivalent functionality to java class PlayerStatisticsCalculator

*/
var PlayerStatsAccumulator = function() {
	var UNREASONABLY_LONG_ELAPSED_TIME_MINUTES = 60;
	var DEFAULT_POINT_ELAPSED_MINUTES = 5;

	this.summarizeGameData = function(arrayOfGameData) {
		var allPlayerStats = {};
		for (var i = 0; i < arrayOfGameData.length; i++) {
			updateStatsForGame(allPlayerStats, arrayOfGameData[i]);
		}
		return allPlayerStats;
	}

	function updateStatsForGame(allPlayerStats, game) {
		var playedInGame = [];
		var points = JSON.parse(game.pointsJson);
		for (var i = 0; i < points.length; i++) {
			var point = points[i];
			updateTimePlayedStats(allPlayerStats, point);

			var events = point.events;
			var lastEvent = null;
			for (var j = 0; j < events.length; j++) {
				var event = events[j];
				var passer = isOffense(event) && event.passer != null ? getStatsForPlayer(allPlayerStats,event.passer) : null;
				var receiver = isOffense(event) && event.receiver != null ? getStatsForPlayer(allPlayerStats,event.receiver) : null;
				var defender = isDefense(event) && event.defender != null ? getStatsForPlayer(allPlayerStats,event.defender) : null;

				if (event.action == 'Catch') {
					passer.passes++;
					receiver.catches++;
					receiver.touches++;
					if (isFirstOffenseEvent(event, lastEvent)) {
						passer.touches++;
					}
				} else if (event.action == 'Drop') {
					passer.passes++;
					receiver.drops++;
					receiver.plusMinusCount--;
					if (isFirstOffenseEvent(event, lastEvent)) {
						passer.touches++;
					}
				} else if (isOffense(event) && (event.action == 'Throwaway' || event.action == 'Stall' || event.action == 'MiscPenalty')) {
					passer.passes++;
					if (event.action == 'Throwaway') {
						passer.throwaways++;
					} else if (event.action == 'Stall') {
						passer.stalls++;
					} else if (event.action == 'MiscPenalty') {
						passer.miscPenalties++;
					}
					passer.plusMinusCount--;
					if (isFirstOffenseEvent(event, lastEvent)) {
						passer.touches++;
					}
				} else if (event.action == 'Pull') {
					defender.pulls++;
					updateHangtimeForPull(event, defender);
				} else if (event.action == 'PullOb') {
					defender.pullsOB++;
				} else if (event.action == 'D') {
					defender.ds++;
					defender.plusMinusCount++;
				} else if (event.action == 'Callahan') {
					if (isDefense(event)) {
						defender.callahans++;
						defender.goals++;
						defender.ds++;
						defender.touches++;
						defender.plusMinusCount++;
						defender.plusMinusCount++; // double for a callahan
						updatePlusMinusLine(allPlayerStats, point, true, isOline(point));
					} else {
						passer.passes++;
						passer.throwaways++;
						passer.callahaneds++;
						passer.plusMinusCount--;
						updatePlusMinusLine(allPlayerStats, point, false, isOline(point));
					}
				} else if (event.action == 'Goal') {
					if (isOffense(event)) {
						passer.assists++;
						passer.passes++;
						receiver.touches++;
						receiver.goals++;
						receiver.catches++;
						passer.plusMinusCount++;
						receiver.plusMinusCount++;
						if (isFirstOffenseEvent(event, lastEvent)) {
							passer.touches++;
						}
					}
					updatePlusMinusLine(allPlayerStats, point, isOffense(event), isOline(point));
				}
				if (isOffense(event) && passer != null && passer.passes > 0) {
					var passPercent = (passer.passes - passerTurnovers(passer)) / passer.passes * 100;
					passer.passSuccess = Math.round(passPercent);
				}
				if (isOffense(event) && receiver != null && receiver.catches > 0) {
					var catchPercent = receiver.catches / (receiver.catches + receiver.drops) * 100;
					receiver.catchSuccess = Math.round(catchPercent);
				}
				lastEvent = event;
			}
            updatePointsPlayedStats(allPlayerStats, point, playedInGame);
		}
		for (var k = 0; k < playedInGame.length; k++) {
			getStatsForPlayer(allPlayerStats,playedInGame[k]).gamesPlayed++;
		}
	}

	function updateTimePlayedStats(allPlayerStats, point) {
		if (point.line) {
			var playersInEntirePoint = getPlayersInEntirePoint(point);
			var playersInPartOfPoint = getPlayersInPartOfPoint(point);
			// players who played all of point
			for (var i = 0; i < playersInEntirePoint.length; i++) {
				var playerStats = getStatsForPlayer(allPlayerStats, playersInEntirePoint[i]);
				playerStats.secondsPlayed += elapsedTimeForPoint(point);
			}
			// players that were subbed in/out (ascribe half of the point time)
			for (var i = 0; i < playersInPartOfPoint.length; i++) {
				var playerStats = getStatsForPlayer(allPlayerStats, playersInPartOfPoint[i]);
				var elapsedTime = elapsedTimeForPoint(point);
				if (elapsedTime) {
					elapsedTime = elapsedTime / 2;
				}
				playerStats.secondsPlayed += elapsedTime;
			}
		}
	}

	function updatePointsPlayedStats(allPlayerStats, point, playedInGame) {
		if (point.line) {
			var playersInEntirePoint = getPlayersInEntirePoint(point);
			var playersInPartOfPoint = getPlayersInPartOfPoint(point);
			// players who played all of point
			for (var i = 0; i < playersInEntirePoint.length; i++) {
				var name = playersInEntirePoint[i];
				addPlayerName(playedInGame, name);
				var playerStats = getStatsForPlayer(allPlayerStats, name);
				playerStats.pointsPlayed++;
				if (isOline(point)) {
					playerStats.oPointsPlayed++;
				} else {
					playerStats.dPointsPlayed++;
				}
			}
			// players who played in part of point
			for (var i = 0; i < playersInPartOfPoint.length; i++) {
				var name = playersInPartOfPoint[i];
				addPlayerName(playedInGame, name);
				var playerStats = getStatsForPlayer(allPlayerStats, name);
				playerStats.pointsPlayed += .5;
				if (isOline(point)) {
					playerStats.oPointsPlayed += .5;
				} else {
					playerStats.dPointsPlayed += .5;
				}
			}
		}
	}

	function updatePlusMinusLine(allPlayerStats, point, isOurGoal, isOline) {
		if (point.line) {
			for (var i = 0; i < point.line.length; i++) {
				var playerName = point.line[i];
				var playerStats = getStatsForPlayer(allPlayerStats,playerName);
				if (isOurGoal) {
					if (isOline) {
						playerStats.plusMinusOLine++;
					} else {
						playerStats.plusMinusDLine++
					}
				} else {
					if (isOline) {
						playerStats.plusMinusOLine--;
					} else {
						playerStats.plusMinusDLine--;
					}
				}
			}
		}
	}

	// answer the players that played during the entire point (were not
	// substituted in or out)
	function getPlayersInEntirePoint(point) {
		if (point.line) {
			if (point.substitutions) {
				var players = point.line.slice();
				for (var i = 0; i < point.substitutions.length; i++) {
					var fromPlayer = point.substitutions[i].fromPlayer;
					var toPlayer = point.substitutions[i].toPlayer;
					// drop both players that are part of a substitution
					removePlayerName(players, fromPlayer);
					removePlayerName(players, toPlayer);
				}
				return players;
			} else {
				return point.line
			}
		} else {
			return [];
		}
	}

	// answer the players that were substituted in or out during the point
	function getPlayersInPartOfPoint(point) {
		if (point.substitutions) {
			var players = [];
			for (var i = 0; i < point.substitutions.length; i++) {
				var fromPlayer = point.substitutions[i].fromPlayer;
				var toPlayer = point.substitutions[i].toPlayer;
				// add both players that are part of a substitution
				addPlayerName(players, fromPlayer);
				addPlayerName(players, toPlayer);
			}
			return players;
		} else {
			return [];
		}
	}

	function getStatsForPlayer(allPlayerStats, name) {
		var playerStats = allPlayerStats[name];
		if (!playerStats) {
			playerStats = {};
			allPlayerStats[name] = playerStats;

			playerStats.playerName = name;
			playerStats.plusMinusCount = 0;
			playerStats.plusMinusOLine = 0;
			playerStats.plusMinusDLine = 0;
			playerStats.gamesPlayed = 0;
			playerStats.pointsPlayed = 0;
			playerStats.oPointsPlayed = 0;
			playerStats.dPointsPlayed = 0;
			playerStats.goals = 0;
			playerStats.callahans = 0;
			playerStats.callahaneds = 0;
			playerStats.assists = 0;
			playerStats.passes = 0;
			playerStats.passSuccess = 0;
			playerStats.catches = 0;
			playerStats.catchSuccess = 0;
			playerStats.drops = 0;
			playerStats.throwaways = 0;
			playerStats.stalls = 0;
			playerStats.miscPenalties = 0;
			playerStats.ds = 0;
			playerStats.pulls = 0;
			playerStats.pullsWithHangtime = 0;
			playerStats.pullsOB = 0;
			playerStats.pullsTotalHangtime = 0;
			playerStats.pullsAvgHangtimeMillis = 0;
			playerStats.touches = 0;
			playerStats.secondsPlayed = 0;

		}
		return playerStats;
	}

	function removePlayerName(names, playerName) {
		var i = names.indexOf(playerName);
		if (i != -1) {
			names.splice(i, 1);
		}
	}

	function addPlayerName(names, playerName) {
		// don't add it if already there
		for (var i = 0; i < names.length; i++) {
			if (names[i] == playerName) {
				return;
			}
		}
		names.push(playerName);
	}

	function isOline(point) {
		return point.summary.lineType == 'O';
	}

	function isDline(point) {
		return point.summary.lineType == 'D';
	}

	function elapsedTimeForPoint(point) {
		var elapsedTime = point.summary.elapsedTime;
		if (!elapsedTime) {
			elapsedTime = 0;
		}
		return elapsedTime > UNREASONABLY_LONG_ELAPSED_TIME_MINUTES * 60 ? DEFAULT_POINT_ELAPSED_MINUTES * 60 : elapsedTime;
	}

	function isOffense(event) {
		return event.type == 'Offense';
	}

	function isDefense(event) {
		return event.type == 'Defense';
	}

	function isFirstOffenseEvent(event, previousEvent) {
		return isOffense(event) && (previousEvent == null || !(isOffense(previousEvent)));
	}

	function updateHangtimeForPull(pullEvent, playerStat) {
		if (pullEvent.details && pullEvent.details.hangtime) {
			playerStat.pullsWithHangtime++;
			playerStat.pullsTotalHangtime += pullEvent.details.hangtime;
			playerStat.pullsAvgHangtimeMillis = playerStat.pullsTotalHangtime / playerStat.pullsWithHangtime;
		}
	}

	function passerTurnovers(playerStat) {
		return playerStat.throwaways + playerStat.stalls + playerStat.miscPenalties;
	}

}
